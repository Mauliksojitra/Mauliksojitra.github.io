(window.webpackJsonp = window.webpackJsonp || []).push([[1], { 0: function (t, e, n) { t.exports = n("zUnb") }, zUnb: function (t, e, n) { "use strict"; function r(t) { return "function" == typeof t } n.r(e); let s = !1; const i = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } }; function o(t) { setTimeout(() => { throw t }, 0) } const a = { closed: !0, next(t) { }, error(t) { if (i.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, l = (() => Array.isArray || (t => t && "number" == typeof t.length))(); function c(t) { return null !== t && "object" == typeof t } const u = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let h = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: n, _unsubscribe: s, _subscriptions: i } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof t) n.remove(this); else if (null !== n) for (let t = 0; t < n.length; ++t)n[t].remove(this); if (r(s)) try { s.call(this) } catch (o) { e = o instanceof u ? d(o.errors) : [o] } if (l(i)) { let t = -1, n = i.length; for (; ++t < n;) { const n = i[t]; if (c(n)) try { n.unsubscribe() } catch (o) { e = e || [], o instanceof u ? e = e.concat(d(o.errors)) : e.push(o) } } } if (e) throw new u(e) } add(e) { let n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: r } = n; if (null === r) n._parentOrParents = this; else if (r instanceof t) { if (r === this) return n; n._parentOrParents = [r, this] } else { if (-1 !== r.indexOf(this)) return n; r.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [n] : s.push(n), n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function d(t) { return t.reduce((t, e) => t.concat(e instanceof u ? e.errors : e), []) } const p = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())(); class f extends h { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!t) { this.destination = a; break } if ("object" == typeof t) { t instanceof f ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new m(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new m(this, t, e, n) } } [p]() { return this } static create(t, e, n) { const r = new f(t, e, n); return r.syncErrorThrowable = !1, r } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class m extends f { constructor(t, e, n, s) { let i; super(), this._parentSubscriber = t; let o = this; r(e) ? i = e : e && (i = e.next, n = e.error, s = e.complete, e !== a && (o = Object.create(e), r(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = i, this._error = n, this._complete = s } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; i.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = i; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); i.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), i.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(t, e, n) { if (!i.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (r) { return i.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = r, t.syncErrorThrown = !0, !0) : (o(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const g = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")(); function y(t) { return t } let _ = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: r } = this, s = function (t, e, n) { if (t) { if (t instanceof f) return t; if (t[p]) return t[p]() } return t || e || n ? new f(t, e, n) : new f(a) }(t, e, n); if (s.add(r ? r.call(s, this.source) : this.source || i.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), i.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { i.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: r } = t; if (e || r) return !1; t = n && n instanceof f ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = v(e))((e, n) => { let r; r = this.subscribe(e => { try { t(e) } catch (s) { n(s), r && r.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [g]() { return this } pipe(...t) { return 0 === t.length ? this : (0 === (e = t).length ? y : 1 === e.length ? e[0] : function (t) { return e.reduce((t, e) => e(t), t) })(this); var e } toPromise(t) { return new (t = v(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function v(t) { if (t || (t = i.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const w = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })(); class b extends h { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class C extends f { constructor(t) { super(t), this.destination = t } } let S = (() => { class t extends _ { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [p]() { return new C(this) } lift(t) { const e = new x(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new w; if (!this.isStopped) { const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].next(t) } } error(t) { if (this.closed) throw new w; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, r = e.slice(); for (let s = 0; s < n; s++)r[s].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new w; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let r = 0; r < e; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new w; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new w; return this.hasError ? (t.error(this.thrownError), h.EMPTY) : this.isStopped ? (t.complete(), h.EMPTY) : (this.observers.push(t), new b(this, t)) } asObservable() { const t = new _; return t.source = this, t } } return t.create = (t, e) => new x(t, e), t })(); class x extends S { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : h.EMPTY } } function E(t) { return t && "function" == typeof t.schedule } class k extends f { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } const T = t => e => { for (let n = 0, r = t.length; n < r && !e.closed; n++)e.next(t[n]); e.complete() }; function P() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const O = P(), A = t => t && "number" == typeof t.length && "function" != typeof t; function M(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const I = t => { if (t && "function" == typeof t[g]) return r = t, t => { const e = r[g](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (A(t)) return T(t); if (M(t)) return n = t, t => (n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, o), t); if (t && "function" == typeof t[O]) return e = t, t => { const n = e[O](); for (; ;) { const e = n.next(); if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = c(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, n, r }; function R(t, e, n, r, s = new k(t, n, r)) { if (!s.closed) return e instanceof _ ? e.subscribe(s) : I(e)(s) } class N extends f { notifyNext(t, e, n, r, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } function j(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new D(t, e)) } } class D { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new F(t, this.project, this.thisArg)) } } class F extends f { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function L(t, e) { return new _(n => { const r = new h; let s = 0; return r.add(e.schedule((function () { s !== t.length ? (n.next(t[s++]), n.closed || r.add(this.schedule())) : n.complete() }))), r }) } function U(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[g] }(t)) return function (t, e) { return new _(n => { const r = new h; return r.add(e.schedule(() => { const s = t[g](); r.add(s.subscribe({ next(t) { r.add(e.schedule(() => n.next(t))) }, error(t) { r.add(e.schedule(() => n.error(t))) }, complete() { r.add(e.schedule(() => n.complete())) } })) })), r }) }(t, e); if (M(t)) return function (t, e) { return new _(n => { const r = new h; return r.add(e.schedule(() => t.then(t => { r.add(e.schedule(() => { n.next(t), r.add(e.schedule(() => n.complete())) })) }, t => { r.add(e.schedule(() => n.error(t))) }))), r }) }(t, e); if (A(t)) return L(t, e); if (function (t) { return t && "function" == typeof t[O] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new _(n => { const r = new h; let s; return r.add(() => { s && "function" == typeof s.return && s.return() }), r.add(e.schedule(() => { s = t[O](), r.add(e.schedule((function () { if (n.closed) return; let t, e; try { const n = s.next(); t = n.value, e = n.done } catch (r) { return void n.error(r) } e ? n.complete() : (n.next(t), this.schedule()) }))) })), r }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof _ ? t : new _(I(t)) } function z(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? r => r.pipe(z((n, r) => U(t(n, r)).pipe(j((t, s) => e(n, t, r, s))), n)) : ("number" == typeof e && (n = e), e => e.lift(new H(t, n))) } class H { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new B(t, this.project, this.concurrent)) } } class B extends N { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(e, t, n) } _innerSub(t, e, n) { const r = new k(this, e, n), s = this.destination; s.add(r); const i = R(this, t, void 0, void 0, r); i !== r && s.add(i) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t, e, n, r, s) { this.destination.next(e) } notifyComplete(t) { const e = this.buffer; this.remove(t), this.active--, e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function V(t = Number.POSITIVE_INFINITY) { return z(y, t) } function $(t, e) { return e ? L(t, e) : new _(T(t)) } function q(...t) { let e = Number.POSITIVE_INFINITY, n = null, r = t[t.length - 1]; return E(r) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof r && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof _ ? t[0] : V(e)($(t, n)) } function W() { return function (t) { return t.lift(new Q(t)) } } class Q { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const r = new G(t, n), s = e.subscribe(r); return r.closed || (r.connection = n.connect()), s } } class G extends f { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, r = t._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } class K extends _ { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new h, t.add(this.source.subscribe(new Y(this.getSubject(), this))), t.closed && (this._connection = null, t = h.EMPTY)), t } refCount() { return W()(this) } } const Z = (() => { const t = K.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class Y extends C { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function X(t, e) { return function (n) { let r; if (r = "function" == typeof t ? t : function () { return t }, "function" == typeof e) return n.lift(new J(r, e)); const s = Object.create(n, Z); return s.source = n, s.subjectFactory = r, s } } class J { constructor(t, e) { this.subjectFactory = t, this.selector = e } call(t, e) { const { selector: n } = this, r = this.subjectFactory(), s = n(r).subscribe(t); return s.add(e.subscribe(r)), s } } function tt() { return new S } function et(t) { return { toString: t }.toString() } function nt(t, e, n) { return et(() => { const r = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function s(...t) { if (this instanceof s) return r.apply(this, t), this; const e = new s(...t); return n.annotation = e, n; function n(t, n, r) { const s = t.hasOwnProperty("__parameters__") ? t.__parameters__ : Object.defineProperty(t, "__parameters__", { value: [] }).__parameters__; for (; s.length <= r;)s.push(null); return (s[r] = s[r] || []).push(e), t } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s }) } const rt = nt("Inject", t => ({ token: t })), st = nt("Optional"), it = nt("Self"), ot = nt("SkipSelf"); var at = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); function lt(t) { for (let e in t) if (t[e] === lt) return e; throw Error("Could not find renamed property on target object.") } function ct(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function ut(t) { return { factory: t.factory, providers: t.providers || [], imports: t.imports || [] } } function ht(t) { return dt(t, t[ft]) || dt(t, t[yt]) } function dt(t, e) { return e && e.token === t ? e : null } function pt(t) { return t && (t.hasOwnProperty(mt) || t.hasOwnProperty(_t)) ? t[mt] : null } const ft = lt({ "\u0275prov": lt }), mt = lt({ "\u0275inj": lt }), gt = lt({ "\u0275provFallback": lt }), yt = lt({ ngInjectableDef: lt }), _t = lt({ ngInjectorDef: lt }); function vt(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(vt).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return "" + t.overriddenName; if (t.name) return "" + t.name; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function wt(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const bt = lt({ __forward_ref__: lt }); function Ct(t) { return t.__forward_ref__ = Ct, t.toString = function () { return vt(this()) }, t } function St(t) { return "function" == typeof (e = t) && e.hasOwnProperty(bt) && e.__forward_ref__ === Ct ? t() : t; var e } const xt = "undefined" != typeof globalThis && globalThis, Et = "undefined" != typeof window && window, kt = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Tt = "undefined" != typeof global && global, Pt = xt || Tt || Et || kt, Ot = lt({ "\u0275cmp": lt }), At = lt({ "\u0275dir": lt }), Mt = lt({ "\u0275pipe": lt }), It = lt({ "\u0275mod": lt }), Rt = lt({ "\u0275loc": lt }), Nt = lt({ "\u0275fac": lt }), jt = lt({ __NG_ELEMENT_ID__: lt }); class Dt { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = ct({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return "InjectionToken " + this._desc } } const Ft = new Dt("INJECTOR", -1), Lt = {}, Ut = /\n/gm, zt = lt({ provide: String, useValue: lt }); let Ht, Bt = void 0; function Vt(t) { const e = Bt; return Bt = t, e } function $t(t) { const e = Ht; return Ht = t, e } function qt(t, e = at.Default) { if (void 0 === Bt) throw new Error("inject() must be called from an injection context"); return null === Bt ? Qt(t, void 0, e) : Bt.get(t, e & at.Optional ? null : void 0, e) } function Wt(t, e = at.Default) { return (Ht || qt)(St(t), e) } function Qt(t, e, n) { const r = ht(t); if (r && "root" == r.providedIn) return void 0 === r.value ? r.value = r.factory() : r.value; if (n & at.Optional) return null; if (void 0 !== e) return e; throw new Error(`Injector: NOT_FOUND [${vt(t)}]`) } function Gt(t) { const e = []; for (let n = 0; n < t.length; n++) { const r = St(t[n]); if (Array.isArray(r)) { if (0 === r.length) throw new Error("Arguments array must have arguments."); let t = void 0, n = at.Default; for (let e = 0; e < r.length; e++) { const s = r[e]; s instanceof st || "Optional" === s.ngMetadataName || s === st ? n |= at.Optional : s instanceof ot || "SkipSelf" === s.ngMetadataName || s === ot ? n |= at.SkipSelf : s instanceof it || "Self" === s.ngMetadataName || s === it ? n |= at.Self : t = s instanceof rt || s === rt ? s.token : s } e.push(Wt(t, n)) } else e.push(Wt(r)) } return e } class Kt { get(t, e = Lt) { if (e === Lt) { const e = new Error(`NullInjectorError: No provider for ${vt(t)}!`); throw e.name = "NullInjectorError", e } return e } } class Zt { } class Yt { } function Xt(t, e) { t.forEach(t => Array.isArray(t) ? Xt(t, e) : e(t)) } function Jt(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function te(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } var ee = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }({}), ne = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.Native = 1] = "Native", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }({}); const re = {}, se = []; let ie = 0; function oe(t) { return et(() => { const e = {}, n = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === ee.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || se, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || ne.Emulated, id: "c", styles: t.styles || se, _: null, setInput: null, schemas: t.schemas || null, tView: null }, r = t.directives, s = t.features, i = t.pipes; return n.id += ie++, n.inputs = he(t.inputs, e), n.outputs = he(t.outputs), s && s.forEach(t => t(n)), n.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(ae) : null, n.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(le) : null, n }) } function ae(t) { return pe(t) || function (t) { return t[At] || null }(t) } function le(t) { return function (t) { return t[Mt] || null }(t) } const ce = {}; function ue(t) { const e = { type: t.type, bootstrap: t.bootstrap || se, declarations: t.declarations || se, imports: t.imports || se, exports: t.exports || se, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && et(() => { ce[t.id] = t.type }), e } function he(t, e) { if (null == t) return re; const n = {}; for (const r in t) if (t.hasOwnProperty(r)) { let s = t[r], i = s; Array.isArray(s) && (i = s[1], s = s[0]), n[s] = r, e && (e[s] = i) } return n } const de = oe; function pe(t) { return t[Ot] || null } function fe(t, e) { return t.hasOwnProperty(Nt) ? t[Nt] : null } function me(t, e) { const n = t[It] || null; if (!n && !0 === e) throw new Error(`Type ${vt(t)} does not have '\u0275mod' property.`); return n } function ge(t) { return Array.isArray(t) && "object" == typeof t[1] } function ye(t) { return Array.isArray(t) && !0 === t[1] } function _e(t) { return 0 != (8 & t.flags) } function ve(t) { return 2 == (2 & t.flags) } function we(t) { return 1 == (1 & t.flags) } function be(t) { return null !== t.template } function Ce(t) { return 0 != (512 & t[2]) } class Se { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function xe() { return Ee } function Ee(t) { return t.type.prototype.ngOnChanges && (t.setInput = Te), ke } function ke() { const t = Pe(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === re) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function Te(t, e, n, r) { const s = Pe(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: re, current: null }), i = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[n], l = o[a]; i[a] = new Se(l && l.currentValue, e, o === re), t[r] = e } function Pe(t) { return t.__ngSimpleChanges__ || null } xe.ngInherit = !0; let Oe = void 0; function Ae(t) { return !!t.listen } const Me = { createRenderer: (t, e) => void 0 !== Oe ? Oe : "undefined" != typeof document ? document : void 0 }; function Ie(t) { for (; Array.isArray(t);)t = t[0]; return t } function Re(t, e) { return Ie(e[t.index]) } function Ne(t, e) { return t.data[e + 20] } function je(t, e) { const n = e[t]; return ge(n) ? n : n[0] } function De(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function Fe(t) { return 4 == (4 & t[2]) } function Le(t) { return 128 == (128 & t[2]) } function Ue(t, e) { return null === t || null == e ? null : t[e] } function ze(t) { t[18] = 0 } function He(t, e) { t[5] += e; let n = t, r = t[3]; for (; null !== r && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)r[5] += e, n = r, r = r[3] } const Be = { lFrame: ln(null), bindingsEnabled: !0, checkNoChangesMode: !1 }; function Ve() { return Be.bindingsEnabled } function $e() { return Be.lFrame.lView } function qe() { return Be.lFrame.tView } function We(t) { Be.lFrame.contextLView = t } function Qe() { return Be.lFrame.previousOrParentTNode } function Ge(t, e) { Be.lFrame.previousOrParentTNode = t, Be.lFrame.isParent = e } function Ke() { return Be.lFrame.isParent } function Ze() { return Be.checkNoChangesMode } function Ye(t) { Be.checkNoChangesMode = t } function Xe() { const t = Be.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e } function Je() { return Be.lFrame.bindingIndex++ } function tn(t, e) { const n = Be.lFrame; n.bindingIndex = n.bindingRootIndex = t, en(e) } function en(t) { Be.lFrame.currentDirectiveIndex = t } function nn() { return Be.lFrame.currentQueryIndex } function rn(t) { Be.lFrame.currentQueryIndex = t } function sn(t, e) { const n = an(); Be.lFrame = n, n.previousOrParentTNode = e, n.lView = t } function on(t, e) { const n = an(), r = t[1]; Be.lFrame = n, n.previousOrParentTNode = e, n.lView = t, n.tView = r, n.contextLView = t, n.bindingIndex = r.bindingStartIndex } function an() { const t = Be.lFrame, e = null === t ? null : t.child; return null === e ? ln(t) : e } function ln(t) { const e = { previousOrParentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: 0, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null }; return null !== t && (t.child = e), e } function cn() { const t = Be.lFrame; return Be.lFrame = t.parent, t.previousOrParentTNode = null, t.lView = null, t } const un = cn; function hn() { const t = cn(); t.isParent = !0, t.tView = null, t.selectedIndex = 0, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function dn() { return Be.lFrame.selectedIndex } function pn(t) { Be.lFrame.selectedIndex = t } function fn() { const t = Be.lFrame; return Ne(t.tView, t.selectedIndex) } function mn(t, e) { for (let n = e.directiveStart, r = e.directiveEnd; n < r; n++) { const e = t.data[n].type.prototype, { ngAfterContentInit: r, ngAfterContentChecked: s, ngAfterViewInit: i, ngAfterViewChecked: o, ngOnDestroy: a } = e; r && (t.contentHooks || (t.contentHooks = [])).push(-n, r), s && ((t.contentHooks || (t.contentHooks = [])).push(n, s), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, s)), i && (t.viewHooks || (t.viewHooks = [])).push(-n, i), o && ((t.viewHooks || (t.viewHooks = [])).push(n, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a) } } function gn(t, e, n) { vn(t, e, 3, n) } function yn(t, e, n, r) { (3 & t[2]) === n && vn(t, e, n, r) } function _n(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function vn(t, e, n, r) { const s = null != r ? r : -1; let i = 0; for (let o = void 0 !== r ? 65535 & t[18] : 0; o < e.length; o++)if ("number" == typeof e[o + 1]) { if (i = e[o], null != r && i >= r) break } else e[o] < 0 && (t[18] += 65536), (i < s || -1 == s) && (wn(t, n, e, o), t[18] = (4294901760 & t[18]) + o + 2), o++ } function wn(t, e, n, r) { const s = n[r] < 0, i = n[r + 1], o = t[s ? -n[r] : n[r]]; s ? t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e && (t[2] += 2048, i.call(o)) : i.call(o) } class bn { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function Cn(t, e, n) { const r = Ae(t); let s = 0; for (; s < n.length;) { const i = n[s]; if ("number" == typeof i) { if (0 !== i) break; s++; const o = n[s++], a = n[s++], l = n[s++]; r ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = i, a = n[++s]; xn(o) ? r && t.setProperty(e, o, a) : r ? t.setAttribute(e, o, a) : e.setAttribute(o, a), s++ } } return s } function Sn(t) { return 3 === t || 4 === t || 6 === t } function xn(t) { return 64 === t.charCodeAt(0) } function En(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let r = 0; r < e.length; r++) { const s = e[r]; "number" == typeof s ? n = s : 0 === n || kn(t, n, s, null, -1 === n || 2 === n ? e[++r] : null) } } return t } function kn(t, e, n, r, s) { let i = 0, o = t.length; if (-1 === e) o = -1; else for (; i < t.length;) { const n = t[i++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = i - 1; break } } } for (; i < t.length;) { const e = t[i]; if ("number" == typeof e) break; if (e === n) { if (null === r) return void (null !== s && (t[i + 1] = s)); if (r === t[i + 1]) return void (t[i + 2] = s) } i++, null !== r && i++, null !== s && i++ } -1 !== o && (t.splice(o, 0, e), i = o + 1), t.splice(i++, 0, n), null !== r && t.splice(i++, 0, r), null !== s && t.splice(i++, 0, s) } function Tn(t) { return -1 !== t } function Pn(t) { return 32767 & t } function On(t) { return t >> 16 } function An(t, e) { let n = On(t), r = e; for (; n > 0;)r = r[15], n--; return r } function Mn(t) { return "string" == typeof t ? t : null == t ? "" : "" + t } function In(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : Mn(t) } const Rn = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(Pt))(); function Nn(t) { return { name: "window", target: t.ownerDocument.defaultView } } function jn(t) { return { name: "document", target: t.ownerDocument } } function Dn(t) { return t instanceof Function ? t() : t } let Fn = !0; function Ln(t) { const e = Fn; return Fn = t, e } let Un = 0; function zn(t, e) { const n = Bn(t, e); if (-1 !== n) return n; const r = e[1]; r.firstCreatePass && (t.injectorIndex = e.length, Hn(r.data, t), Hn(e, null), Hn(r.blueprint, null)); const s = Vn(t, e), i = t.injectorIndex; if (Tn(s)) { const t = Pn(s), n = An(s, e), r = n[1].data; for (let s = 0; s < 8; s++)e[i + s] = n[t + s] | r[t + s] } return e[i + 8] = s, i } function Hn(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Bn(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null == e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function Vn(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = e[6], r = 1; for (; n && -1 === n.injectorIndex;)n = (e = e[15]) ? e[6] : null, r++; return n ? n.injectorIndex | r << 16 : -1 } function $n(t, e, n) { !function (t, e, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(jt) && (r = n[jt]), null == r && (r = n[jt] = Un++); const s = 255 & r, i = 1 << s, o = 64 & s, a = 32 & s, l = e.data; 128 & s ? o ? a ? l[t + 7] |= i : l[t + 6] |= i : a ? l[t + 5] |= i : l[t + 4] |= i : o ? a ? l[t + 3] |= i : l[t + 2] |= i : a ? l[t + 1] |= i : l[t] |= i }(t, e, n) } function qn(t, e, n, r = at.Default, s) { if (null !== t) { const s = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(jt) ? t[jt] : void 0; return "number" == typeof e && e > 0 ? 255 & e : e }(n); if ("function" == typeof s) { sn(e, t); try { const t = s(); if (null != t || r & at.Optional) return t; throw new Error(`No provider for ${In(n)}!`) } finally { un() } } else if ("number" == typeof s) { if (-1 === s) return new Xn(t, e); let i = null, o = Bn(t, e), a = -1, l = r & at.Host ? e[16][6] : null; for ((-1 === o || r & at.SkipSelf) && (a = -1 === o ? Vn(t, e) : e[o + 8], Yn(r, !1) ? (i = e[1], o = Pn(a), e = An(a, e)) : o = -1); -1 !== o;) { a = e[o + 8]; const t = e[1]; if (Zn(s, o, t.data)) { const t = Qn(o, e, n, i, r, l); if (t !== Wn) return t } Yn(r, e[1].data[o + 8] === l) && Zn(s, o, e) ? (i = t, o = Pn(a), e = An(a, e)) : o = -1 } } } if (r & at.Optional && void 0 === s && (s = null), 0 == (r & (at.Self | at.Host))) { const t = e[9], i = $t(void 0); try { return t ? t.get(n, s, r & at.Optional) : Qt(n, s, r & at.Optional) } finally { $t(i) } } if (r & at.Optional) return s; throw new Error(`NodeInjector: NOT_FOUND [${In(n)}]`) } const Wn = {}; function Qn(t, e, n, r, s, i) { const o = e[1], a = o.data[t + 8], l = Gn(a, o, n, null == r ? ve(a) && Fn : r != o && 3 === a.type, s & at.Host && i === a); return null !== l ? Kn(e, o, l, a) : Wn } function Gn(t, e, n, r, s) { const i = t.providerIndexes, o = e.data, a = 1048575 & i, l = t.directiveStart, c = i >> 20, u = s ? a + c : t.directiveEnd; for (let h = r ? a : a + c; h < u; h++) { const t = o[h]; if (h < l && n === t || h >= l && t.type === n) return h } if (s) { const t = o[l]; if (t && be(t) && t.type === n) return l } return null } function Kn(t, e, n, r) { let s = t[n]; const i = e.data; if (s instanceof bn) { const o = s; if (o.resolving) throw new Error("Circular dep for " + In(i[n])); const a = Ln(o.canSeeViewProviders); let l; o.resolving = !0, o.injectImpl && (l = $t(o.injectImpl)), sn(t, r); try { s = t[n] = o.factory(void 0, i, t, r), e.firstCreatePass && n >= r.directiveStart && function (t, e, n) { const { ngOnChanges: r, ngOnInit: s, ngDoCheck: i } = e.type.prototype; if (r) { const r = Ee(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, r), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, r) } s && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, s), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, i)) }(n, i[n], e) } finally { o.injectImpl && $t(l), Ln(a), o.resolving = !1, un() } } return s } function Zn(t, e, n) { const r = 64 & t, s = 32 & t; let i; return i = 128 & t ? r ? s ? n[e + 7] : n[e + 6] : s ? n[e + 5] : n[e + 4] : r ? s ? n[e + 3] : n[e + 2] : s ? n[e + 1] : n[e], !!(i & 1 << t) } function Yn(t, e) { return !(t & at.Self || t & at.Host && e) } class Xn { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return qn(this._tNode, this._lView, t, void 0, e) } } function Jn(t) { return t.ngDebugContext } function tr(t) { return t.ngOriginalError } function er(t, ...e) { t.error(...e) } class nr { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), r = function (t) { return t.ngErrorLogger || er }(t); r(this._console, "ERROR", t), e && r(this._console, "ORIGINAL ERROR", e), n && r(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? Jn(t) ? Jn(t) : this._findContext(tr(t)) : null } _findOriginalError(t) { let e = tr(t); for (; e && tr(e);)e = tr(e); return e } } class rr { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return "SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity + " (see http://g.co/ng/security#xss)" } } let sr = !0, ir = !1; function or() { return ir = !0, sr } const ar = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi, lr = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; var cr = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }({}); function ur(t) { const e = function () { const t = $e(); return t && t[12] }(); return e ? e.sanitize(cr.URL, t) || "" : function (t, e) { const n = function (t) { return t instanceof rr && t.getTypeName() || null }(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see http://g.co/ng/security#xss)`) } return n === e }(t, "URL") ? (r = t) instanceof rr ? r.changingThisBreaksApplicationSecurity : r : (n = Mn(t), (n = String(n)).match(ar) || n.match(lr) ? n : (or() && console.warn(`WARNING: sanitizing unsafe URL value ${n} (see http://g.co/ng/security#xss)`), "unsafe:" + n)); var n, r } function hr(t, e) { t.__ngContext__ = e } function dr(t) { throw new Error("Multiple components match node with tagname " + t.tagName) } function pr() { throw new Error("Cannot mix multi providers and regular providers") } function fr(t, e, n) { let r = t.length; for (; ;) { const s = t.indexOf(e, n); if (-1 === s) return s; if (0 === s || t.charCodeAt(s - 1) <= 32) { const n = e.length; if (s + n === r || t.charCodeAt(s + n) <= 32) return s } n = s + 1 } } function mr(t, e, n) { let r = 0; for (; r < t.length;) { let s = t[r++]; if (n && "class" === s) { if (s = t[r], -1 !== fr(s.toLowerCase(), e, 0)) return !0 } else if (1 === s) { for (; r < t.length && "string" == typeof (s = t[r++]);)if (s.toLowerCase() === e) return !0; return !1 } } return !1 } function gr(t) { return 0 === t.type && "ng-template" !== t.tagName } function yr(t, e, n) { return e === (0 !== t.type || n ? t.tagName : "ng-template") } function _r(t, e, n) { let r = 4; const s = t.attrs || [], i = function (t) { for (let e = 0; e < t.length; e++)if (Sn(t[e])) return e; return t.length }(s); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== l && !yr(t, l, n) || "" === l && 1 === e.length) { if (vr(r)) return !1; o = !0 } } else { const c = 8 & r ? l : e[++a]; if (8 & r && null !== t.attrs) { if (!mr(t.attrs, c, n)) { if (vr(r)) return !1; o = !0 } continue } const u = wr(8 & r ? "class" : l, s, gr(t), n); if (-1 === u) { if (vr(r)) return !1; o = !0; continue } if ("" !== c) { let t; t = u > i ? "" : s[u + 1].toLowerCase(); const e = 8 & r ? t : null; if (e && -1 !== fr(e, c, 0) || 2 & r && c !== t) { if (vr(r)) return !1; o = !0 } } } } else { if (!o && !vr(r) && !vr(l)) return !1; if (o && vr(l)) continue; o = !1, r = l | 1 & r } } return vr(r) || o } function vr(t) { return 0 == (1 & t) } function wr(t, e, n, r) { if (null === e) return -1; let s = 0; if (r || !n) { let n = !1; for (; s < e.length;) { const r = e[s]; if (r === t) return s; if (3 === r || 6 === r) n = !0; else { if (1 === r || 2 === r) { let t = e[++s]; for (; "string" == typeof t;)t = e[++s]; continue } if (4 === r) break; if (0 === r) { s += 4; continue } } s += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const r = t[n]; if ("number" == typeof r) return -1; if (r === e) return n; n++ } return -1 }(e, t) } function br(t, e, n = !1) { for (let r = 0; r < e.length; r++)if (_r(t, e[r], n)) return !0; return !1 } function Cr(t, e) { return t ? ":not(" + e.trim() + ")" : e } function Sr(t) { let e = t[0], n = 1, r = 2, s = "", i = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & r) { const e = t[++n]; s += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & r ? s += "." + o : 4 & r && (s += " " + o); else "" === s || vr(o) || (e += Cr(i, s), s = ""), r = o, i = i || !vr(r); n++ } return "" !== s && (e += Cr(i, s)), e } const xr = {}; function Er(t) { const e = t[3]; return ye(e) ? e[3] : e } function kr(t) { return Pr(t[13]) } function Tr(t) { return Pr(t[4]) } function Pr(t) { for (; null !== t && !ye(t);)t = t[4]; return t } function Or(t) { Ar(qe(), $e(), dn() + t, Ze()) } function Ar(t, e, n, r) { if (!r) if (3 == (3 & e[2])) { const r = t.preOrderCheckHooks; null !== r && gn(e, r, n) } else { const r = t.preOrderHooks; null !== r && yn(e, r, 0, n) } pn(n) } function Mr(t, e) { const n = t.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const s = n[r], i = n[r + 1]; if (-1 !== i) { const n = t.data[i]; rn(s), n.contentQueries(2, e[i], i) } } } function Ir(t, e, n) { return Ae(e) ? e.createElement(t, n) : null === n ? e.createElement(t) : e.createElementNS(n, t) } function Rr(t, e, n, r, s, i, o, a, l, c) { const u = e.blueprint.slice(); return u[0] = s, u[2] = 140 | r, ze(u), u[3] = u[15] = t, u[8] = n, u[10] = o || t && t[10], u[11] = a || t && t[11], u[12] = l || t && t[12] || null, u[9] = c || t && t[9] || null, u[6] = i, u[16] = 2 == e.type ? t[16] : u, u } function Nr(t, e, n, r, s, i) { const o = n + 20, a = t.data[o] || function (t, e, n, r, s, i) { const o = Qe(), a = Ke(), l = a ? o : o && o.parent, c = t.data[n] = $r(0, l && l !== e ? l : null, r, n, s, i); return null === t.firstChild && (t.firstChild = c), o && (!a || null != o.child || null === c.parent && 2 !== o.type ? a || (o.next = c) : o.child = c), c }(t, e, o, r, s, i); return Ge(a, !0), a } function jr(t, e, n) { on(e, e[6]); try { const r = t.viewQuery; null !== r && ds(1, r, n); const s = t.template; null !== s && Lr(t, e, s, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Mr(t, e), t.staticViewQueries && ds(2, t.viewQuery, n); const i = t.components; null !== i && function (t, e) { for (let n = 0; n < e.length; n++)as(t, e[n]) }(e, i) } catch (r) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), r } finally { e[2] &= -5, hn() } } function Dr(t, e, n, r) { const s = e[2]; if (256 == (256 & s)) return; on(e, e[6]); const i = Ze(); try { ze(e), Be.lFrame.bindingIndex = t.bindingStartIndex, null !== n && Lr(t, e, n, 2, r); const o = 3 == (3 & s); if (!i) if (o) { const n = t.preOrderCheckHooks; null !== n && gn(e, n, null) } else { const n = t.preOrderHooks; null !== n && yn(e, n, 0, null), _n(e, 0) } if (function (t) { for (let e = kr(t); null !== e; e = Tr(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const n = t[e], r = n[3]; 0 == (1024 & n[2]) && He(r, 1), n[2] |= 1024 } } }(e), function (t) { for (let e = kr(t); null !== e; e = Tr(e))for (let t = 10; t < e.length; t++) { const n = e[t], r = n[1]; Le(n) && Dr(r, n, r.template, n[8]) } }(e), null !== t.contentQueries && Mr(t, e), !i) if (o) { const n = t.contentCheckHooks; null !== n && gn(e, n) } else { const n = t.contentHooks; null !== n && yn(e, n, 1), _n(e, 1) } !function (t, e) { try { const n = t.expandoInstructions; if (null !== n) { let r = t.expandoStartIndex, s = -1, i = -1; for (let t = 0; t < n.length; t++) { const o = n[t]; "number" == typeof o ? o <= 0 ? (i = 0 - o, pn(i), r += 9 + n[++t], s = r) : r += o : (null !== o && (tn(r, s), o(2, e[s])), s++) } } } finally { pn(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)os(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && ds(2, l, r), !i) if (o) { const n = t.viewCheckHooks; null !== n && gn(e, n) } else { const n = t.viewHooks; null !== n && yn(e, n, 2), _n(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), i || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, He(e[3], -1)) } finally { hn() } } function Fr(t, e, n, r) { const s = e[10], i = !Ze(), o = Fe(e); try { i && !o && s.begin && s.begin(), o && jr(t, e, r), Dr(t, e, n, r) } finally { i && !o && s.end && s.end() } } function Lr(t, e, n, r, s) { const i = dn(); try { pn(-1), 2 & r && e.length > 20 && Ar(t, e, 0, Ze()), n(r, s) } finally { pn(i) } } function Ur(t, e, n) { Ve() && (function (t, e, n, r) { const s = n.directiveStart, i = n.directiveEnd; t.firstCreatePass || zn(n, e), hr(r, e); const o = n.initialInputs; for (let a = s; a < i; a++) { const r = t.data[a], i = be(r); i && ns(e, n, r); const l = Kn(e, t, a, n); hr(l, e), null !== o && rs(0, a - s, l, r, 0, o), i && (je(n.index, e)[8] = l) } }(t, e, n, Re(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const r = n.directiveStart, s = n.directiveEnd, i = t.expandoInstructions, o = t.firstCreatePass, a = n.index - 20, l = Be.lFrame.currentDirectiveIndex; try { pn(a); for (let n = r; n < s; n++) { const r = t.data[n], s = e[n]; en(n), null !== r.hostBindings || 0 !== r.hostVars || null !== r.hostAttrs ? Zr(r, s) : o && i.push(null) } } finally { pn(-1), en(l) } }(t, e, n)) } function zr(t, e, n = Re) { const r = e.localNames; if (null !== r) { let s = e.index + 1; for (let i = 0; i < r.length; i += 2) { const o = r[i + 1], a = -1 === o ? n(e, t) : t[o]; t[s++] = a } } } function Hr(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = Br(1, -1, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function Br(t, e, n, r, s, i, o, a, l, c) { const u = 20 + r, h = u + s, d = function (t, e) { const n = []; for (let r = 0; r < e; r++)n.push(r < t ? null : xr); return n }(u, h); return d[1] = { type: t, id: e, blueprint: d, template: n, queries: null, viewQuery: a, node: null, data: d.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, expandoInstructions: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: c, incompleteFirstPass: !1 } } function Vr(t, e, n, r) { const s = fs(e); s.push(n), t.firstCreatePass && function (t) { return t.cleanup || (t.cleanup = []) }(t).push(r, s.length - 1) } function $r(t, e, n, r, s, i) { return { type: n, index: r, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, tagName: s, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } } function qr(t, e, n) { for (let r in t) if (t.hasOwnProperty(r)) { const s = t[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(e, s) : n[r] = [e, s] } return n } function Wr(t, e, n, r, s, i, o, a) { const l = Re(e, n); let c, u = e.inputs; var h; !a && null != u && (c = u[r]) ? (gs(t, n, c, r, s), ve(e) && function (t, e) { const n = je(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 === e.type && (r = "class" === (h = r) ? "className" : "for" === h ? "htmlFor" : "formaction" === h ? "formAction" : "innerHtml" === h ? "innerHTML" : "readonly" === h ? "readOnly" : "tabindex" === h ? "tabIndex" : h, s = null != o ? o(s, e.tagName || "", r) : s, Ae(i) ? i.setProperty(l, r, s) : xn(r) || (l.setProperty ? l.setProperty(r, s) : l[r] = s)) } function Qr(t, e, n, r) { let s = !1; if (Ve()) { const i = function (t, e, n) { const r = t.directiveRegistry; let s = null; if (r) for (let i = 0; i < r.length; i++) { const o = r[i]; br(n, o.selectors, !1) && (s || (s = []), $n(zn(n, e), t, o.type), be(o) ? (2 & n.flags && dr(n), Xr(t, n), s.unshift(o)) : s.push(o)) } return s }(t, e, n), o = null === r ? null : { "": -1 }; if (null !== i) { let r = 0; s = !0, ts(n, t.data.length, i.length); for (let t = 0; t < i.length; t++) { const e = i[t]; e.providersResolver && e.providersResolver(e) } Yr(t, n, i.length); let a = !1, l = !1; for (let s = 0; s < i.length; s++) { const c = i[s]; n.mergedAttrs = En(n.mergedAttrs, c.hostAttrs), es(t, e, c), Jr(t.data.length - 1, c, o), null !== c.contentQueries && (n.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (n.flags |= 128); const u = c.type.prototype; !a && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index - 20), a = !0), l || !u.ngOnChanges && !u.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index - 20), l = !0), Gr(t, c), r += c.hostVars } !function (t, e) { const n = e.directiveEnd, r = t.data, s = e.attrs, i = []; let o = null, a = null; for (let l = e.directiveStart; l < n; l++) { const t = r[l], n = t.inputs, c = null === s || gr(e) ? null : ss(n, s); i.push(c), o = qr(n, l, o), a = qr(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = i, e.inputs = o, e.outputs = a }(t, n), Kr(t, e, r) } o && function (t, e, n) { if (e) { const r = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const s = n[e[t + 1]]; if (null == s) throw new Error(`Export of name '${e[t + 1]}' not found!`); r.push(e[t], s) } } }(n, r, o) } return n.mergedAttrs = En(n.mergedAttrs, n.attrs), s } function Gr(t, e) { const n = t.expandoInstructions; n.push(e.hostBindings), 0 !== e.hostVars && n.push(e.hostVars) } function Kr(t, e, n) { for (let r = 0; r < n; r++)e.push(xr), t.blueprint.push(xr), t.data.push(null) } function Zr(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function Yr(t, e, n) { const r = 20 - e.index, s = t.data.length - (1048575 & e.providerIndexes); (t.expandoInstructions || (t.expandoInstructions = [])).push(r, s, n) } function Xr(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function Jr(t, e, n) { if (n) { if (e.exportAs) for (let r = 0; r < e.exportAs.length; r++)n[e.exportAs[r]] = t; be(e) && (n[""] = t) } } function ts(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function es(t, e, n) { t.data.push(n); const r = n.factory || (n.factory = fe(n.type)), s = new bn(r, be(n), null); t.blueprint.push(s), e.push(s) } function ns(t, e, n) { const r = Re(e, t), s = Hr(n), i = t[10], o = ls(t, Rr(t, s, null, n.onPush ? 64 : 16, r, e, i, i.createRenderer(r, n))); t[e.index] = o } function rs(t, e, n, r, s, i) { const o = i[e]; if (null !== o) { const t = r.setInput; for (let e = 0; e < o.length;) { const s = o[e++], i = o[e++], a = o[e++]; null !== t ? r.setInput(n, a, s, i) : n[i] = a } } } function ss(t, e) { let n = null, r = 0; for (; r < e.length;) { const s = e[r]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; t.hasOwnProperty(s) && (null === n && (n = []), n.push(s, t[s], e[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function is(t, e, n, r) { return new Array(t, !0, !1, e, null, 0, r, n, null, null) } function os(t, e) { const n = je(e, t); if (Le(n)) { const t = n[1]; 80 & n[2] ? Dr(t, n, t.template, n[8]) : n[5] > 0 && function t(e) { for (let r = kr(e); null !== r; r = Tr(r))for (let e = 10; e < r.length; e++) { const n = r[e]; if (1024 & n[2]) { const t = n[1]; Dr(t, n, t.template, n[8]) } else n[5] > 0 && t(n) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const s = je(n[r], e); Le(s) && s[5] > 0 && t(s) } }(n) } } function as(t, e) { const n = je(e, t), r = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(r, n), jr(r, n, n[8]) } function ls(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function cs(t) { for (; t;) { t[2] |= 64; const e = Er(t); if (Ce(t) && !e) return t; t = e } return null } function us(t, e, n) { const r = e[10]; r.begin && r.begin(); try { Dr(t, e, t.template, n) } catch (s) { throw ms(e, s), s } finally { r.end && r.end() } } function hs(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], r = De(n), s = r[1]; Fr(s, r, s.template, n) } }(t[8]) } function ds(t, e, n) { rn(0), e(t, n) } const ps = (() => Promise.resolve(null))(); function fs(t) { return t[7] || (t[7] = []) } function ms(t, e) { const n = t[9], r = n ? n.get(nr, null) : null; r && r.handleError(e) } function gs(t, e, n, r, s) { for (let i = 0; i < n.length;) { const o = n[i++], a = n[i++], l = e[o], c = t.data[o]; null !== c.setInput ? c.setInput(l, s, r, a) : l[a] = s } } function ys(t, e) { const n = e[3]; return -1 === t.index ? ye(n) ? n : null : n } function _s(t, e) { const n = ys(t, e); return n ? Os(e[11], n[7]) : null } function vs(t, e, n, r, s) { if (null != r) { let i, o = !1; ye(r) ? i = r : ge(r) && (o = !0, r = r[0]); const a = Ie(r); 0 === t && null !== n ? null == s ? Ts(e, n, a) : ks(e, n, a, s || null) : 1 === t && null !== n ? ks(e, n, a, s || null) : 2 === t ? function (t, e, n) { const r = Os(t, e); r && function (t, e, n, r) { Ae(t) ? t.removeChild(e, n, r) : e.removeChild(n) }(t, r, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != i && function (t, e, n, r, s) { const i = n[7]; i !== Ie(n) && vs(e, t, r, i, s); for (let o = 10; o < n.length; o++) { const s = n[o]; Rs(s[1], s, t, e, r, i) } }(e, t, i, n, s) } } function ws(t, e, n, r) { const s = _s(t.node, e); s && Rs(t, e, e[11], n ? 1 : 2, s, r) } function bs(t, e) { const n = t[9], r = n.indexOf(e); 1024 & e[2] && He(e[3], -1), n.splice(r, 1) } function Cs(t, e) { if (t.length <= 10) return; const n = 10 + e, r = t[n]; if (r) { const s = r[17]; null !== s && s !== t && bs(s, r), e > 0 && (t[n - 1][4] = r[4]); const i = te(t, 10 + e); ws(r[1], r, !1, null); const o = i[19]; null !== o && o.detachView(i[1]), r[3] = null, r[4] = null, r[2] &= -129 } return r } function Ss(t, e) { if (!(256 & e[2])) { const n = e[11]; Ae(n) && n.destroyNode && Rs(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return Es(t[1], t); for (; e;) { let n = null; if (ge(e)) n = e[13]; else { const t = e[10]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)ge(e) && Es(e[1], e), e = xs(e, t); null === e && (e = t), ge(e) && Es(e[1], e), n = e && e[4] } e = n } }(e) } } function xs(t, e) { let n; return ge(t) && (n = t[6]) && 2 === n.type ? ys(n, t) : t[3] === e ? null : t[3] } function Es(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const t = e[n[r]]; if (!(t instanceof bn)) { const e = n[r + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2)e[n + 1].call(t[e[n]]); else e.call(t) } } }(t, e), function (t, e) { const n = t.cleanup; if (null !== n) { const t = e[7]; for (let r = 0; r < n.length - 1; r += 2)if ("string" == typeof n[r]) { const s = n[r + 1], i = "function" == typeof s ? s(e) : Ie(e[s]), o = t[n[r + 2]], a = n[r + 3]; "boolean" == typeof a ? i.removeEventListener(n[r], o, a) : a >= 0 ? t[a]() : t[-a].unsubscribe(), r += 2 } else n[r].call(t[n[r + 1]]); e[7] = null } }(t, e); const n = e[6]; n && 3 === n.type && Ae(e[11]) && e[11].destroy(); const r = e[17]; if (null !== r && ye(e[3])) { r !== e[3] && bs(r, e); const n = e[19]; null !== n && n.detachView(t) } } } function ks(t, e, n, r) { Ae(t) ? t.insertBefore(e, n, r) : e.insertBefore(n, r, !0) } function Ts(t, e, n) { Ae(t) ? t.appendChild(e, n) : e.appendChild(n) } function Ps(t, e, n, r) { null !== r ? ks(t, e, n, r) : Ts(t, e, n) } function Os(t, e) { return Ae(t) ? t.parentNode(e) : e.parentNode } function As(t, e, n, r) { const s = function (t, e, n) { let r = e.parent; for (; null != r && (4 === r.type || 5 === r.type);)r = (e = r).parent; if (null == r) { const t = n[6]; return 2 === t.type ? _s(t, n) : n[0] } if (e && 5 === e.type && 4 & e.flags) return Re(e, n).parentNode; if (2 & r.flags) { const e = t.data, n = e[e[r.index].directiveStart].encapsulation; if (n !== ne.ShadowDom && n !== ne.Native) return null } return Re(r, n) }(t, r, e); if (null != s) { const t = e[11], i = function (t, e) { if (2 === t.type) { const n = ys(t, e); return null === n ? null : Ms(n.indexOf(e, 10) - 10, n) } return 4 === t.type || 5 === t.type ? Re(t, e) : null }(r.parent || e[6], e); if (Array.isArray(n)) for (let e = 0; e < n.length; e++)Ps(t, s, n[e], i); else Ps(t, s, n, i) } } function Ms(t, e) { const n = 10 + t + 1; if (n < e.length) { const t = e[n], r = t[1].firstChild; if (null !== r) return function t(e, n) { if (null !== n) { const r = n.type; if (3 === r) return Re(n, e); if (0 === r) return Ms(-1, e[n.index]); if (4 === r || 5 === r) { const r = n.child; if (null !== r) return t(e, r); { const t = e[n.index]; return ye(t) ? Ms(-1, t) : Ie(t) } } { const r = e[16], s = r[6], i = Er(r), o = s.projection[n.projection]; return null != o ? t(i, o) : t(e, n.next) } } return null }(t, r) } return e[7] } function Is(t, e, n, r, s, i, o) { for (; null != n;) { const a = r[n.index], l = n.type; o && 0 === e && (a && hr(Ie(a), r), n.flags |= 4), 64 != (64 & n.flags) && (4 === l || 5 === l ? (Is(t, e, n.child, r, s, i, !1), vs(e, t, s, a, i)) : 1 === l ? Ns(t, e, r, n, s, i) : vs(e, t, s, a, i)), n = o ? n.projectionNext : n.next } } function Rs(t, e, n, r, s, i) { Is(n, r, t.node.child, e, s, i, !1) } function Ns(t, e, n, r, s, i) { const o = n[16], a = o[6].projection[r.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)vs(e, t, s, a[l], i); else Is(t, e, a, o[3], s, i, !0) } function js(t, e, n) { Ae(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Ds(t, e, n) { Ae(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } class Fs { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._viewContainerRef = null } get rootNodes() { const t = this._lView; return null == t[0] ? function t(e, n, r, s, i = !1) { for (; null !== r;) { const o = n[r.index]; if (null !== o && s.push(Ie(o)), ye(o)) for (let e = 10; e < o.length; e++) { const n = o[e], r = n[1].firstChild; null !== r && t(n[1], n, r, s) } const a = r.type; if (4 === a || 5 === a) t(e, n, r.child, s); else if (1 === a) { const e = n[16], i = e[6].projection[r.projection]; if (Array.isArray(i)) s.push(...i); else { const n = Er(e); t(n[1], n, i, s, !0) } } r = i ? r.projectionNext : r.next } return s }(t[1], t, t[6].child, []) : [] } get context() { return this._lView[8] } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._viewContainerRef) { const t = this._viewContainerRef.indexOf(this); t > -1 && this._viewContainerRef.detach(t), this._viewContainerRef = null } Ss(this._lView[1], this._lView) } onDestroy(t) { Vr(this._lView[1], this._lView, null, t) } markForCheck() { cs(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { us(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { Ye(!0); try { us(t, e, n) } finally { Ye(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef(t) { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._viewContainerRef = t } detachFromAppRef() { var t; this._appRef = null, Rs(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class Ls extends Fs { constructor(t) { super(t), this._view = t } detectChanges() { hs(this._view) } checkNoChanges() { !function (t) { Ye(!0); try { hs(t) } finally { Ye(!1) } }(this._view) } get context() { return null } } let Us, zs, Hs; function Bs(t, e, n) { return Us || (Us = class extends t { }), new Us(Re(e, n)) } function Vs(t, e, n, r) { return zs || (zs = class extends t { constructor(t, e, n) { super(), this._declarationView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = Rr(this._declarationView, e, t, 16, null, e.node); n[17] = this._declarationView[this._declarationTContainer.index]; const r = this._declarationView[19]; return null !== r && (n[19] = r.createEmbeddedView(e)), jr(e, n, t), new Fs(n) } }), 0 === n.type ? new zs(r, n, Bs(e, n, r)) : null } function $s(t, e, n, r) { let s; Hs || (Hs = class extends t { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostView = n } get element() { return Bs(e, this._hostTNode, this._hostView) } get injector() { return new Xn(this._hostTNode, this._hostView) } get parentInjector() { const t = Vn(this._hostTNode, this._hostView), e = An(t, this._hostView), n = function (t, e, n) { if (n.parent && -1 !== n.parent.injectorIndex) { const t = n.parent.injectorIndex; let e = n.parent; for (; null != e.parent && t == e.parent.injectorIndex;)e = e.parent; return e } let r = On(t), s = e, i = e[6]; for (; r > 1;)s = s[15], i = s[6], r--; return i }(t, this._hostView, this._hostTNode); return Tn(t) && null != n ? new Xn(n, e) : new Xn(null, this._hostView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { return null !== this._lContainer[8] && this._lContainer[8][t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, e, n) { const r = t.createEmbeddedView(e || {}); return this.insert(r, n), r } createComponent(t, e, n, r, s) { const i = n || this.parentInjector; if (!s && null == t.ngModule && i) { const t = i.get(Zt, null); t && (s = t) } const o = t.create(i, r, void 0, s); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, r = n[1]; if (t.destroyed) throw new Error("Cannot insert a destroyed View in a ViewContainer!"); if (this.allocateContainerIfNeeded(), ye(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], r = new Hs(e, e[6], e[3]); r.detach(r.indexOf(t)) } } const s = this._adjustIndex(e); return function (t, e, n, r) { const s = 10 + r, i = n.length; r > 0 && (n[s - 1][4] = e), r < i - 10 ? (e[4] = n[s], Jt(n, 10 + r, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(r, n, this._lContainer, s), ws(r, n, !0, Ms(s, this._lContainer)), t.attachToViewContainerRef(this), Jt(this._lContainer[8], s, t), t } move(t, e) { if (t.destroyed) throw new Error("Cannot move a destroyed View in a ViewContainer!"); return this.insert(t, e) } indexOf(t) { const e = this._lContainer[8]; return null !== e ? e.indexOf(t) : -1 } remove(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1); !function (t, e) { const n = Cs(t, e); n && Ss(n[1], n) }(this._lContainer, e), te(this._lContainer[8], e) } detach(t) { this.allocateContainerIfNeeded(); const e = this._adjustIndex(t, -1), n = Cs(this._lContainer, e); return n && null != te(this._lContainer[8], e) ? new Fs(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } allocateContainerIfNeeded() { null === this._lContainer[8] && (this._lContainer[8] = []) } }); const i = r[n.index]; if (ye(i)) s = i; else { let t; if (4 === n.type) t = Ie(i); else if (t = r[11].createComment(""), Ce(r)) { const e = r[11], s = Re(n, r); ks(e, Os(e, s), t, function (t, e) { return Ae(t) ? t.nextSibling(e) : e.nextSibling }(e, s)) } else As(r[1], r, t, n); r[n.index] = s = is(i, r, t, n), ls(r, s) } return new Hs(s, n, r) } let qs = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Ws(), t })(); const Ws = function (t = !1) { return function (t, e, n) { if (!n && ve(t)) { const n = je(t.index, e); return new Fs(n, n) } return 3 === t.type || 0 === t.type || 4 === t.type || 5 === t.type ? new Fs(e[16], e) : null }(Qe(), $e(), t) }, Qs = Function, Gs = new Dt("Set Injector scope."), Ks = {}, Zs = {}, Ys = []; let Xs = void 0; function Js() { return void 0 === Xs && (Xs = new Kt), Xs } function ti(t, e = null, n = null, r) { return new ei(t, n, e || Js(), r) } class ei { constructor(t, e, n, r = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; e && Xt(e, n => this.processProvider(n, t, e)), Xt([t], t => this.processInjectorType(t, [], s)), this.records.set(Ft, ri(void 0, this)); const i = this.records.get(Gs); this.scope = null != i ? i.value : null, this.source = r || ("object" == typeof t ? null : vt(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = Lt, n = at.Default) { this.assertNotDestroyed(); const r = Vt(this); try { if (!(n & at.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (s = t) || "object" == typeof s && s instanceof Dt) && ht(t); e = n && this.injectableDefInScope(n) ? ri(ni(t), Ks) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & at.Self ? Js() : this.parent).get(t, e = n & at.Optional && e === Lt ? null : e) } catch (i) { if ("NullInjectorError" === i.name) { if ((i.ngTempTokenPath = i.ngTempTokenPath || []).unshift(vt(t)), r) throw i; return function (t, e, n, r) { const s = t.ngTempTokenPath; throw e.__source && s.unshift(e.__source), t.message = function (t, e, n, r = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = vt(e); if (Array.isArray(e)) s = e.map(vt).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let r = e[n]; t.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : vt(r))) } s = `{${t.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${s}]: ${t.replace(Ut, "\n  ")}` }("\n" + t.message, s, n, r), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(i, t, "R3InjectorError", this.source) } throw i } finally { Vt(r) } var s } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(vt(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = St(t))) return !1; let r = pt(t); const s = null == r && t.ngModule || void 0, i = void 0 === s ? t : s, o = -1 !== n.indexOf(i); if (void 0 !== s && (r = pt(s)), null == r) return !1; if (null != r.imports && !o) { let t; n.push(i); try { Xt(r.imports, r => { this.processInjectorType(r, e, n) && (void 0 === t && (t = []), t.push(r)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: r } = t[e]; Xt(r, t => this.processProvider(t, n, r || Ys)) } } this.injectorDefTypes.add(i), this.records.set(i, ri(r.factory, Ks)); const a = r.providers; if (null != a && !o) { const e = t; Xt(a, t => this.processProvider(t, e, a)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, n) { let r = ii(t = St(t)) ? t : St(t && t.provide); const s = function (t, e, n) { return si(t) ? ri(void 0, t.useValue) : ri(function (t, e, n) { let r = void 0; if (ii(t)) { const e = St(t); return fe(e) || ni(e) } if (si(t)) r = () => St(t.useValue); else if ((s = t) && s.useFactory) r = () => t.useFactory(...Gt(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) r = () => Wt(St(t.useExisting)); else { const s = St(t && (t.useClass || t.provide)); if (s || function (t, e, n) { let r = ""; throw t && e && (r = ` - only instances of Provider and Type are allowed, got: [${e.map(t => t == n ? "?" + n + "?" : "...").join(", ")}]`), new Error(`Invalid provider for the NgModule '${vt(t)}'` + r) }(e, n, t), !function (t) { return !!t.deps }(t)) return fe(s) || ni(s); r = () => new s(...Gt(t.deps)) } var s; return r }(t, e, n), Ks) }(t, e, n); if (ii(t) || !0 !== t.multi) { const t = this.records.get(r); t && void 0 !== t.multi && pr() } else { let e = this.records.get(r); e ? void 0 === e.multi && pr() : (e = ri(void 0, Ks, !0), e.factory = () => Gt(e.multi), this.records.set(r, e)), r = t, e.multi.push(t) } this.records.set(r, s) } hydrate(t, e) { var n; return e.value === Zs ? function (t) { throw new Error("Cannot instantiate cyclic dependency! " + t) }(vt(t)) : e.value === Ks && (e.value = Zs, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { return !!t.providedIn && ("string" == typeof t.providedIn ? "any" === t.providedIn || t.providedIn === this.scope : this.injectorDefTypes.has(t.providedIn)) } } function ni(t) { const e = ht(t), n = null !== e ? e.factory : fe(t); if (null !== n) return n; const r = pt(t); if (null !== r) return r.factory; if (t instanceof Dt) throw new Error(`Token ${vt(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = function (t, e) { const n = []; for (let r = 0; r < t; r++)n.push("?"); return n }(e); throw new Error(`Can't resolve all parameters for ${vt(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[ft] || t[yt] || t[gt] && t[gt]()); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function ri(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function si(t) { return null !== t && "object" == typeof t && zt in t } function ii(t) { return "function" == typeof t } const oi = function (t, e, n) { return function (t, e = null, n = null, r) { const s = ti(t, e, n, r); return s._resolveInjectorDefTypes(), s }({ name: n }, e, t, n) }; let ai = (() => { class t { static create(t, e) { return Array.isArray(t) ? oi(t, e, "") : oi(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = Lt, t.NULL = new Kt, t.\u0275prov = ct({ token: t, providedIn: "any", factory: () => Wt(Ft) }), t.__NG_ELEMENT_ID__ = -1, t })(); const li = new Dt("AnalyzeForEntryComponents"); function ci(t, e, n) { let r = n ? t.styles : null, s = n ? t.classes : null, i = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? i = t : 1 == i ? s = wt(s, t) : 2 == i && (r = wt(r, t + ": " + e[++o] + ";")) } n ? t.styles = r : t.stylesWithoutHost = r, n ? t.classes = s : t.classesWithoutHost = s } let ui = null; function hi() { if (!ui) { const t = Pt.Symbol; if (t && t.iterator) ui = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (ui = n) } } } return ui } function di(t) { return !!pi(t) && (Array.isArray(t) || !(t instanceof Map) && hi() in t) } function pi(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function fi(t, e, n) { return t[e] = n } function mi(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function gi(t, e, n, r) { const s = $e(); return mi(s, Je(), e) && (qe(), function (t, e, n, r, s, i) { const o = Re(t, e), a = e[11]; if (null == r) Ae(a) ? a.removeAttribute(o, n, i) : o.removeAttribute(n); else { const e = null == s ? Mn(r) : s(r, t.tagName || "", n); Ae(a) ? a.setAttribute(o, n, e, i) : i ? o.setAttributeNS(i, n, e) : o.setAttribute(n, e) } }(fn(), s, t, e, n, r)), gi } function yi(t, e, n, r, s, i, o, a) { const l = $e(), c = qe(), u = t + 20, h = c.firstCreatePass ? function (t, e, n, r, s, i, o, a, l) { const c = e.consts, u = Nr(e, n[6], t, 0, o || null, Ue(c, a)); Qr(e, n, u, Ue(c, l)), mn(e, u); const h = u.tViews = Br(2, -1, r, s, i, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c), d = $r(0, null, 2, -1, null, null); return d.injectorIndex = u.injectorIndex, h.node = d, null !== e.queries && (e.queries.template(e, u), h.queries = e.queries.embeddedTView(u)), u }(t, c, l, e, n, r, s, i, o) : c.data[u]; Ge(h, !1); const d = l[11].createComment(""); As(c, l, d, h), hr(d, l), ls(l, l[u] = is(d, l, d, h)), we(h) && Ur(c, l, h), null != o && zr(l, h, a) } function _i(t, e = at.Default) { const n = $e(); return null == n ? Wt(t, e) : qn(Qe(), n, St(t), e) } function vi(t, e, n) { const r = $e(); return mi(r, Je(), e) && Wr(qe(), fn(), r, t, e, r[11], n, !1), vi } function wi(t, e, n, r, s) { const i = s ? "class" : "style"; gs(t, n, e.inputs[i], i, r) } function bi(t, e, n, r) { const s = $e(), i = qe(), o = 20 + t, a = s[11], l = s[o] = Ir(e, a, Be.lFrame.currentNamespace), c = i.firstCreatePass ? function (t, e, n, r, s, i, o) { const a = e.consts, l = Ue(a, i), c = Nr(e, n[6], t, 3, s, l); return Qr(e, n, c, Ue(a, o)), null !== c.attrs && ci(c, c.attrs, !1), null !== c.mergedAttrs && ci(c, c.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, c), c }(t, i, s, 0, e, n, r) : i.data[o]; Ge(c, !0); const u = c.mergedAttrs; null !== u && Cn(a, l, u); const h = c.classes; null !== h && Ds(a, l, h); const d = c.styles; null !== d && js(a, l, d), As(i, s, l, c), 0 === Be.lFrame.elementDepthCount && hr(l, s), Be.lFrame.elementDepthCount++, we(c) && (Ur(i, s, c), function (t, e, n) { if (_e(e)) { const r = e.directiveEnd; for (let s = e.directiveStart; s < r; s++) { const e = t.data[s]; e.contentQueries && e.contentQueries(1, n[s], s) } } }(i, c, s)), null !== r && zr(s, c) } function Ci() { let t = Qe(); Ke() ? Be.lFrame.isParent = !1 : (t = t.parent, Ge(t, !1)); const e = t; Be.lFrame.elementDepthCount--; const n = qe(); n.firstCreatePass && (mn(n, t), _e(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && wi(n, e, $e(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && wi(n, e, $e(), e.stylesWithoutHost, !1) } function Si(t, e, n, r) { bi(t, e, n, r), Ci() } function xi() { return $e() } function Ei(t) { return !!t && "function" == typeof t.then } function ki(t, e, n = !1, r) { const s = $e(), i = qe(), o = Qe(); return function (t, e, n, r, s, i, o = !1, a) { const l = we(r), c = t.firstCreatePass && (t.cleanup || (t.cleanup = [])), u = fs(e); let h = !0; if (3 === r.type) { const d = Re(r, e), p = a ? a(d) : re, f = p.target || d, m = u.length, g = a ? t => a(Ie(t[r.index])).target : r.index; if (Ae(n)) { let o = null; if (!a && l && (o = function (t, e, n, r) { const s = t.cleanup; if (null != s) for (let i = 0; i < s.length - 1; i += 2) { const t = s[i]; if (t === n && s[i + 1] === r) { const t = e[7], n = s[i + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (i += 2) } return null }(t, e, s, r.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = i, o.__ngLastListenerFn__ = i, h = !1; else { i = Pi(r, e, i, !1); const t = n.listen(p.name || f, s, i); u.push(i, t), c && c.push(s, g, m, m + 1) } } else i = Pi(r, e, i, !0), f.addEventListener(s, i, o), u.push(i), c && c.push(s, g, m, o) } const d = r.outputs; let p; if (h && null !== d && (p = d[s])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(i), o = u.length; u.push(i, t), c && c.push(s, r.index, o, -(o + 1)) } } }(i, s, s[11], o, t, e, n, r), ki } function Ti(t, e, n) { try { return !1 !== e(n) } catch (r) { return ms(t, r), !1 } } function Pi(t, e, n, r) { return function s(i) { if (i === Function) return n; const o = 2 & t.flags ? je(t.index, e) : e; 0 == (32 & e[2]) && cs(o); let a = Ti(e, n, i), l = s.__ngNextListenerFn__; for (; l;)a = Ti(e, l, i) && a, l = l.__ngNextListenerFn__; return r && !1 === a && (i.preventDefault(), i.returnValue = !1), a } } function Oi(t = 1) { return function (t) { return (Be.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Be.lFrame.contextLView))[8] }(t) } function Ai(t, e = "") { const n = $e(), r = qe(), s = t + 20, i = r.firstCreatePass ? Nr(r, n[6], t, 3, null, null) : r.data[s], o = n[s] = function (t, e) { return Ae(e) ? e.createText(t) : e.createTextNode(t) }(e, n[11]); As(r, n, o, i), Ge(i, !1) } function Mi(t) { return Ii("", t, ""), Mi } function Ii(t, e, n) { const r = $e(), s = function (t, e, n, r) { return mi(t, Je(), n) ? e + Mn(n) + r : xr }(r, t, e, n); return s !== xr && function (t, e, n) { const r = function (t, e) { return Ie(e[t + 20]) }(e, t), s = t[11]; Ae(s) ? s.setValue(r, n) : r.textContent = n }(r, dn(), s), Ii } function Ri(t, e, n) { const r = $e(); return mi(r, Je(), e) && Wr(qe(), fn(), r, t, e, r[11], n, !0), Ri } function Ni(t, e) { const n = De(t)[1], r = n.data.length - 1; mn(n, { directiveStart: r, directiveEnd: r + 1 }) } class ji { } class Di { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${vt(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let Fi = (() => { class t { } return t.NULL = new Di, t })(), Li = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = () => Ui(t), t })(); const Ui = function (t) { return Bs(t, Qe(), $e()) }; class zi { } var Hi = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }({}); let Bi = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Vi(), t })(); const Vi = function () { const t = $e(), e = je(Qe().index, t); return function (t) { const e = t[11]; if (Ae(e)) return e; throw new Error("Cannot inject Renderer2 when the application uses Renderer3!") }(ge(e) ? e : t) }; let $i = (() => { class t { } return t.\u0275prov = ct({ token: t, providedIn: "root", factory: () => null }), t })(); class qi { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Wi = new qi("10.0.9"); class Qi { constructor() { } supports(t) { return di(t) } create(t) { return new Ki(t) } } const Gi = (t, e) => e; class Ki { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || Gi } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, r = 0, s = null; for (; e || n;) { const i = !n || e && e.currentIndex < Ji(n, r, s) ? e : n, o = Ji(i, r, s), a = i.currentIndex; if (i === n) r--, n = n._nextRemoved; else if (e = e._next, null == i.previousIndex) r++; else { s || (s = []); const t = o - r, e = a - r; if (t != e) { for (let n = 0; n < t; n++) { const r = n < s.length ? s[n] : s[n] = 0, i = r + n; e <= i && i < t && (s[n] = r + 1) } s[i.previousIndex] = e - t } } o !== a && t(i, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !di(t)) throw new Error(`Error trying to diff '${vt(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, r, s = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], r = this._trackByFn(e, n), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, n, r, e)), Object.is(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, r, e), i = !0), s = s._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[hi()](); let r; for (; !(r = n.next()).done;)e(r.value) } }(t, t => { r = this._trackByFn(e, t), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, t, r, e)), Object.is(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, r, e), i = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t, e; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = e)t.previousIndex = t.currentIndex, e = t._nextMoved; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, r) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, r)) : null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, r)) : t = this._addAfter(new Zi(e, n), s, r), t } _verifyReinsertion(t, e, n, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? t = this._reinsertAfter(s, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, s = t._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Xi), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Xi), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class Zi { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class Yi { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Object.is(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class Xi { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new Yi, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Ji(t, e, n) { const r = t.previousIndex; if (null === r) return r; let s = 0; return n && r < n.length && (s = n[r]), r + e + s } class to { constructor() { } supports(t) { return t instanceof Map || pi(t) } create() { return new eo } } class eo { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || pi(t))) throw new Error(`Error trying to diff '${vt(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const r = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, r) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const r = n._prev, s = n._next; return r && (r._next = s), s && (s._prev = r), n._next = null, n._prev = null, n } const n = new no(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class no { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } let ro = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend IterableDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new ot, new st]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = ct({ token: t, providedIn: "root", factory: () => new t([new Qi]) }), t })(), so = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => { if (!n) throw new Error("Cannot extend KeyValueDiffers without a parent injector"); return t.create(e, n) }, deps: [[t, new ot, new st]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = ct({ token: t, providedIn: "root", factory: () => new t([new to]) }), t })(); const io = [new to], oo = new ro([new Qi]), ao = new so(io); let lo = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => co(t, Li), t })(); const co = function (t, e) { return Vs(t, e, Qe(), $e()) }; let uo = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => ho(t, Li), t })(); const ho = function (t, e) { return $s(t, e, Qe(), $e()) }, po = {}; class fo extends Fi { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = pe(t); return new yo(e, this.ngModule) } } function mo(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const go = new Dt("SCHEDULER_TOKEN", { providedIn: "root", factory: () => Rn }); class yo extends ji { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(Sr).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return mo(this.componentDef.inputs) } get outputs() { return mo(this.componentDef.outputs) } create(t, e, n, r) { const s = (r = r || this.ngModule) ? function (t, e) { return { get: (n, r, s) => { const i = t.get(n, po, s); return i !== po || r === po ? i : e.get(n, r, s) } } }(t, r.injector) : t, i = s.get(zi, Me), o = s.get($i, null), a = i.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = n ? function (t, e, n) { if (Ae(t)) return t.selectRootElement(e, n === ne.ShadowDom); let r = "string" == typeof e ? t.querySelector(e) : e; return r.textContent = "", r }(a, n, this.componentDef.encapsulation) : Ir(l, i.createRenderer(null, this.componentDef), function (t) { const e = t.toLowerCase(); return "svg" === e ? "http://www.w3.org/2000/svg" : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)), u = this.componentDef.onPush ? 576 : 528, h = { components: [], scheduler: Rn, clean: ps, playerHandler: null, flags: 0 }, d = Br(0, -1, null, 1, 0, null, null, null, null, null), p = Rr(null, d, h, u, null, null, i, a, o, s); let f, m; on(p, null); try { const t = function (t, e, n, r, s, i) { const o = n[1]; n[20] = t; const a = Nr(o, null, 0, 3, null, null), l = a.mergedAttrs = e.hostAttrs; null !== l && (ci(a, l, !0), null !== t && (Cn(s, t, l), null !== a.classes && Ds(s, t, a.classes), null !== a.styles && js(s, t, a.styles))); const c = r.createRenderer(t, e), u = Rr(n, Hr(e), null, e.onPush ? 64 : 16, n[20], a, r, c, void 0); return o.firstCreatePass && ($n(zn(a, n), o, e.type), Xr(o, a), ts(a, n.length, 1)), ls(n, u), n[20] = u }(c, this.componentDef, p, i, a); if (c) if (n) Cn(a, c, ["ng-version", Wi.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let r = 1, s = 2; for (; r < t.length;) { let i = t[r]; if ("string" == typeof i) 2 === s ? "" !== i && e.push(i, t[++r]) : 8 === s && n.push(i); else { if (!vr(s)) break; s = i } r++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && Cn(a, c, t), e && e.length > 0 && Ds(a, c, e.join(" ")) } if (m = Ne(d, 0), void 0 !== e) { const t = m.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const r = e[n]; t.push(null != r ? Array.from(r) : null) } } f = function (t, e, n, r, s) { const i = n[1], o = function (t, e, n) { const r = Qe(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), Yr(t, r, 1), es(t, e, n)); const s = Kn(e, t, e.length - 1, r); hr(s, e); const i = Re(r, e); return i && hr(i, e), s }(i, n, e); r.components.push(o), t[8] = o, s && s.forEach(t => t(o, e)), e.contentQueries && e.contentQueries(1, o, n.length - 1); const a = Qe(); if (i.firstCreatePass && (null !== e.hostBindings || null !== e.hostAttrs)) { pn(a.index - 20); const t = n[1]; Gr(t, e), Kr(t, n, e.hostVars), Zr(e, o) } return o }(t, this.componentDef, p, h, [Ni]), jr(d, p, null) } finally { hn() } const g = new _o(this.componentType, f, Bs(Li, m, p), p, m); return d.node.child = m, g } } class _o extends class { }{ constructor(t, e, n, r, s) { super(), this.location = n, this._rootLView = r, this._tNode = s, this.destroyCbs = [], this.instance = e, this.hostView = this.changeDetectorRef = new Ls(r), function (t, e, n, r) { let s = t.node; null == s && (t.node = s = $r(0, null, 2, -1, null, null)), r[6] = s }(r[1], 0, 0, r), this.componentType = t } get injector() { return new Xn(this._tNode, this._rootLView) } destroy() { this.destroyCbs && (this.destroyCbs.forEach(t => t()), this.destroyCbs = null, !this.hostView.destroyed && this.hostView.destroy()) } onDestroy(t) { this.destroyCbs && this.destroyCbs.push(t) } } const vo = void 0; var wo = ["en", [["a", "p"], ["AM", "PM"], vo], [["AM", "PM"], vo, vo], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], vo, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], vo, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", vo, "{1} 'at' {0}", vo], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let bo = {}; function Co(t) { return t in bo || (bo[t] = Pt.ng && Pt.ng.common && Pt.ng.common.locales && Pt.ng.common.locales[t]), bo[t] } var So = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }({}); let xo = "en-US"; function Eo(t) { var e, n; n = "Expected localeId to be defined", null == (e = t) && function (t, e, n, r) { throw new Error("ASSERTION ERROR: " + t + ` [Expected=> null != ${e} <=Actual]`) }(n, e), "string" == typeof t && (xo = t.toLowerCase().replace(/_/g, "-")) } const ko = new Map; class To extends Zt { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new fo(this); const n = me(t), r = t[Rt] || null; r && Eo(r), this._bootstrapComponents = Dn(n.bootstrap), this._r3Injector = ti(t, e, [{ provide: Zt, useValue: this }, { provide: Fi, useValue: this.componentFactoryResolver }], vt(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = ai.THROW_IF_NOT_FOUND, n = at.Default) { return t === ai || t === Zt || t === Ft ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Po extends Yt { constructor(t) { super(), this.moduleType = t, null !== me(t) && function t(e) { if (null !== e.\u0275mod.id) { const t = e.\u0275mod.id; (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${vt(e)} vs ${vt(e.name)}`) })(t, ko.get(t), e), ko.set(t, e) } let n = e.\u0275mod.imports; n instanceof Function && (n = n()), n && n.forEach(e => t(e)) }(t) } create(t) { return new To(this.moduleType, t) } } function Oo(t, e, n) { const r = Xe() + t, s = $e(); return s[r] === xr ? fi(s, r, n ? e.call(n) : e()) : function (t, e) { return t[e] }(s, r) } function Ao(t, e, n, r) { return function (t, e, n, r, s, i) { const o = e + n; return mi(t, o, s) ? fi(t, o + 1, i ? r.call(i, s) : r(s)) : function (t, e) { const n = t[e]; return n === xr ? void 0 : n }(t, o + 1) }($e(), Xe(), t, e, n, r) } const Mo = class extends S { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { let r, s = t => null, i = () => null; t && "object" == typeof t ? (r = this.__isAsync ? e => { setTimeout(() => t.next(e)) } : e => { t.next(e) }, t.error && (s = this.__isAsync ? e => { setTimeout(() => t.error(e)) } : e => { t.error(e) }), t.complete && (i = this.__isAsync ? () => { setTimeout(() => t.complete()) } : () => { t.complete() })) : (r = this.__isAsync ? e => { setTimeout(() => t(e)) } : e => { t(e) }, e && (s = this.__isAsync ? t => { setTimeout(() => e(t)) } : t => { e(t) }), n && (i = this.__isAsync ? () => { setTimeout(() => n()) } : () => { n() })); const o = super.subscribe(r, s, i); return t instanceof h && t.add(o), o } }; function Io() { return this._results[hi()]() } class Ro { constructor() { this.dirty = !0, this._results = [], this.changes = new Mo, this.length = 0; const t = hi(), e = Ro.prototype; e[t] || (e[t] = Io) } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t) { this._results = function t(e, n) { void 0 === n && (n = e); for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? (n === e && (n = e.slice(0, r)), t(s, n)) : n !== e && n.push(s) } return n }(t), this.dirty = !1, this.length = this._results.length, this.last = this._results[this.length - 1], this.first = this._results[0] } notifyOnChanges() { this.changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class No { constructor(t) { this.queryList = t, this.matches = null } clone() { return new No(this.queryList) } setDirty() { this.queryList.setDirty() } } class jo { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); r.push(this.queries[n.indexInDeclarationView].clone()) } return new jo(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== qo(t, e).matches && this.queries[e].setDirty() } } class Do { constructor(t, e, n, r = null) { this.predicate = t, this.descendants = e, this.isStatic = n, this.read = r } } class Fo { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const r = null !== e ? e.length : 0, s = this.getByIndex(n).embeddedTView(t, r); s && (s.indexInDeclarationView = n, null !== e ? e.push(s) : e = [s]) } return null !== e ? new Fo(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Lo { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Lo(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && !1 === this.metadata.descendants) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 4 === n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let r = 0; r < n.length; r++) { const s = n[r]; this.matchTNodeWithReadOption(t, e, Uo(e, s)), this.matchTNodeWithReadOption(t, e, Gn(e, t, s, !1, !1)) } else n === lo ? 0 === e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Gn(e, t, n, !1, !1)) } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const r = this.metadata.read; if (null !== r) if (r === Li || r === uo || r === lo && 0 === e.type) this.addMatch(e.index, -2); else { const n = Gn(e, t, r, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function Uo(t, e) { const n = t.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === e) return n[r + 1]; return null } function zo(t, e, n, r) { return -1 === n ? function (t, e) { return 3 === t.type || 4 === t.type ? Bs(Li, t, e) : 0 === t.type ? Vs(lo, Li, t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === Li ? Bs(Li, e, t) : n === lo ? Vs(lo, Li, e, t) : n === uo ? $s(uo, Li, e, t) : void 0 }(t, e, r) : Kn(t, t[1], n, e) } function Ho(t, e, n, r) { const s = e[19].queries[r]; if (null === s.matches) { const r = t.data, i = n.matches, o = []; for (let t = 0; t < i.length; t += 2) { const s = i[t]; o.push(s < 0 ? null : zo(e, r[s], i[t + 1], n.metadata.read)) } s.matches = o } return s.matches } function Bo(t) { const e = $e(), n = qe(), r = nn(); rn(r + 1); const s = qo(n, r); if (t.dirty && Fe(e) === s.metadata.isStatic) { if (null === s.matches) t.reset([]); else { const i = s.crossesNgTemplate ? function t(e, n, r, s) { const i = e.queries.getByIndex(r), o = i.matches; if (null !== o) { const a = Ho(e, n, i, r); for (let e = 0; e < o.length; e += 2) { const r = o[e]; if (r > 0) s.push(a[e / 2]); else { const i = o[e + 1], a = n[-r]; for (let e = 10; e < a.length; e++) { const n = a[e]; n[17] === n[3] && t(n[1], n, i, s) } if (null !== a[9]) { const e = a[9]; for (let n = 0; n < e.length; n++) { const r = e[n]; t(r[1], r, i, s) } } } } } return s }(n, e, r, []) : Ho(n, e, s, r); t.reset(i), t.notifyOnChanges() } return !0 } return !1 } function Vo(t, e, n) { !function (t, e, n, r, s, i) { t.firstCreatePass && function (t, e, n) { null === t.queries && (t.queries = new Fo), t.queries.track(new Lo(e, -1)) }(t, new Do(n, r, !1, s)), function (t, e) { const n = new Ro; Vr(t, e, n, n.destroy), null === e[19] && (e[19] = new jo), e[19].queries.push(new No(n)) }(t, e) }(qe(), $e(), t, e, n) } function $o() { return t = $e(), e = nn(), t[19].queries[e].queryList; var t, e } function qo(t, e) { return t.queries.getByIndex(e) } const Wo = new Dt("Application Initializer"); let Qo = (() => { class t { constructor(t) { this.appInits = t, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); Ei(e) && t.push(e) } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Wo, 8)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const Go = new Dt("AppId"), Ko = { provide: Go, useFactory: function () { return `${Zo()}${Zo()}${Zo()}` }, deps: [] }; function Zo() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Yo = new Dt("Platform Initializer"), Xo = new Dt("Platform ID"), Jo = new Dt("appBootstrapListener"); let ta = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const ea = new Dt("LocaleId"), na = new Dt("DefaultCurrencyCode"); class ra { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const sa = function (t) { return new Po(t) }, ia = sa, oa = function (t) { return Promise.resolve(sa(t)) }, aa = function (t) { const e = sa(t), n = Dn(me(t).declarations).reduce((t, e) => { const n = pe(e); return n && t.push(new yo(n)), t }, []); return new ra(e, n) }, la = aa, ca = function (t) { return Promise.resolve(aa(t)) }; let ua = (() => { class t { constructor() { this.compileModuleSync = ia, this.compileModuleAsync = oa, this.compileModuleAndAllComponentsSync = la, this.compileModuleAndAllComponentsAsync = ca } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const ha = (() => Promise.resolve(0))(); function da(t) { "undefined" == typeof Zone ? ha.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class pa { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Mo(!1), this.onMicrotaskEmpty = new Mo(!1), this.onStable = new Mo(!1), this.onError = new Mo(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(), this._nesting = 0, this._outer = this._inner = Zone.current, Zone.wtfZoneSpec && (this._inner = this._inner.fork(Zone.wtfZoneSpec)), Zone.TaskTrackingZoneSpec && (this._inner = this._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (this._inner = this._inner.fork(Zone.longStackTraceZoneSpec)), this.shouldCoalesceEventChangeDetection = e, this.lastRequestAnimationFrameId = -1, this.nativeRequestAnimationFrame = function () { let t = Pt.requestAnimationFrame, e = Pt.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const r = e[Zone.__symbol__("OriginalDelegate")]; r && (e = r) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = !!t.shouldCoalesceEventChangeDetection && t.nativeRequestAnimationFrame && (() => { !function (t) { -1 === t.lastRequestAnimationFrameId && (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Pt, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, ya(t), ga(t) }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), ya(t)) }(t) }); t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0, maybeDelayChangeDetection: e }, onInvokeTask: (n, r, s, i, o, a) => { try { return _a(t), n.invokeTask(s, i, o, a) } finally { e && "eventTask" === i.type && e(), va(t) } }, onInvoke: (e, n, r, s, i, o, a) => { try { return _a(t), e.invoke(r, s, i, o, a) } finally { va(t) } }, onHasTask: (e, n, r, s) => { e.hasTask(r, s), n === r && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, ya(t), ga(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, n, r, s) => (e.handleError(r, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(this) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!pa.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (pa.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, r) { const s = this._inner, i = s.scheduleEventTask("NgZoneEvent: " + r, t, ma, fa, fa); try { return s.runTask(i, e, n) } finally { s.cancelTask(i) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } function fa() { } const ma = {}; function ga(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function ya(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || t.shouldCoalesceEventChangeDetection && -1 !== t.lastRequestAnimationFrameId) } function _a(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function va(t) { t._nesting--, ga(t) } class wa { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Mo, this.onMicrotaskEmpty = new Mo, this.onStable = new Mo, this.onError = new Mo } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, r) { return t.apply(e, n) } } let ba = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { pa.assertNotInAngularZone(), da(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) da(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let r = -1; e && e > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== r), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: r, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(Wt(pa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), Ca = (() => { class t { constructor() { this._applications = new Map, Ea.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return Ea.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); class Sa { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } let xa, Ea = new Sa; const ka = new Dt("AllowMultipleToken"); class Ta { constructor(t, e) { this.name = t, this.token = e } } function Pa(t, e, n = []) { const r = "Platform: " + e, s = new Dt(r); return (e = []) => { let i = Oa(); if (!i || i.injector.get(ka, !1)) if (t) t(n.concat(e).concat({ provide: s, useValue: !0 })); else { const t = n.concat(e).concat({ provide: s, useValue: !0 }, { provide: Gs, useValue: "platform" }); !function (t) { if (xa && !xa.destroyed && !xa.injector.get(ka, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); xa = t.get(Aa); const e = t.get(Yo, null); e && e.forEach(t => t()) }(ai.create({ providers: t, name: r })) } return function (t) { const e = Oa(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } } function Oa() { return xa && !xa.destroyed ? xa : null } let Aa = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new wa : ("zone.js" === t ? void 0 : t) || new pa({ enableLongStackTrace: or(), shouldCoalesceEventChangeDetection: e }), n }(e ? e.ngZone : void 0, e && e.ngZoneEventCoalescing || !1), r = [{ provide: pa, useValue: n }]; return n.run(() => { const e = ai.create({ providers: r, parent: this.injector, name: t.moduleType.name }), s = t.create(e), i = s.injector.get(nr, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return s.onDestroy(() => Ra(this._modules, s)), n.runOutsideAngular(() => n.onError.subscribe({ next: t => { i.handleError(t) } })), function (t, e, n) { try { const r = n(); return Ei(r) ? r.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : r } catch (r) { throw e.runOutsideAngular(() => t.handleError(r)), r } }(i, n, () => { const t = s.injector.get(Qo); return t.runInitializers(), t.donePromise.then(() => (Eo(s.injector.get(ea, "en-US") || "en-US"), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const n = Ma({}, e); return function (t, e, n) { const r = new Po(n); return Promise.resolve(r) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(Ia); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${vt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(Wt(ai)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); function Ma(t, e) { return Array.isArray(e) ? e.reduce(Ma, t) : Object.assign(Object.assign({}, t), e) } let Ia = (() => { class t { constructor(t, e, n, r, s, i) { this._zone = t, this._console = e, this._injector = n, this._exceptionHandler = r, this._componentFactoryResolver = s, this._initStatus = i, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._enforceNoNewChanges = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._enforceNoNewChanges = or(), this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const o = new _(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), a = new _(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { pa.assertNotInAngularZone(), da(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { pa.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = q(o, a.pipe(t => W()(X(tt)(t)))) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof ji ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const r = n.isBoundToModule ? void 0 : this._injector.get(Zt), s = n.create(ai.NULL, [], e || n.selector, r); s.onDestroy(() => { this._unloadComponent(s) }); const i = s.injector.get(ba, null); return i && s.injector.get(Ca).registerApplication(s.location.nativeElement, i), this._loadComponent(s), or() && this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges(); if (this._enforceNoNewChanges) for (let t of this._views) t.checkNoChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; Ra(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(Jo, []).concat(this._bootstrapListeners).forEach(e => e(t)) } _unloadComponent(t) { this.detachView(t.hostView), Ra(this.components, t) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()) } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(Wt(pa), Wt(ta), Wt(ai), Wt(nr), Wt(Fi), Wt(Qo)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); function Ra(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class Na { } class ja { } const Da = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let Fa = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || Da } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, r] = t.split("#"); return void 0 === r && (r = "default"), n("zn8P")(e).then(t => t[r]).then(t => La(t, e, r)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, r] = t.split("#"), s = "NgFactory"; return void 0 === r && (r = "default", s = ""), n("zn8P")(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[r + s]).then(t => La(t, e, r)) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(ua), Wt(ja, 8)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); function La(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const Ua = Pa(null, "core", [{ provide: Xo, useValue: "unknown" }, { provide: Aa, deps: [ai] }, { provide: Ca, deps: [] }, { provide: ta, deps: [] }]), za = [{ provide: Ia, useClass: Ia, deps: [pa, ta, ai, nr, Fi, Qo] }, { provide: go, deps: [pa], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: Qo, useClass: Qo, deps: [[new st, Wo]] }, { provide: ua, useClass: ua, deps: [] }, Ko, { provide: ro, useFactory: function () { return oo }, deps: [] }, { provide: so, useFactory: function () { return ao }, deps: [] }, { provide: ea, useFactory: function (t) { return Eo(t = t || "undefined" != typeof $localize && $localize.locale || "en-US"), t }, deps: [[new rt(ea), new st, new ot]] }, { provide: na, useValue: "USD" }]; let Ha = (() => { class t { constructor(t) { } } return t.\u0275mod = ue({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t)(Wt(Ia)) }, providers: za }), t })(); const Ba = [{ displayName: "Angular", isSelected: !1 }, { displayName: "Angular.js", isSelected: !1 }, { displayName: "ASP.NET", isSelected: !1 }, { displayName: "CSS", isSelected: !1 }, { displayName: "Others", isSelected: !1 }]; let Va = (() => { class t { constructor() { this.onTagUpdate = new Mo, this.tags = Ba } toogleTagSelection(t) { const e = this.tags.reduce((t, e) => t + (e.isSelected ? 1 : 0), 0), n = this.tags.find(e => e.displayName === t); e <= 1 && n.isSelected || (n.isSelected = !n.isSelected, this.onTagUpdate.emit({ tags: this.tags.filter(t => t.isSelected) })) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), $a = null; function qa() { return $a } const Wa = new Dt("DocumentToken"); let Qa = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ factory: Ga, token: t, providedIn: "platform" }), t })(); function Ga() { return Wt(Za) } const Ka = new Dt("Location Initialized"); let Za = (() => { class t extends Qa { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = qa().getLocation(), this._history = qa().getHistory() } getBaseHrefFromDOM() { return qa().getBaseHref(this._doc) } onPopState(t) { qa().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", t, !1) } onHashChange(t) { qa().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", t, !1) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { Ya() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { Ya() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Wa)) }, t.\u0275prov = ct({ factory: Xa, token: t, providedIn: "platform" }), t })(); function Ya() { return !!window.history.pushState } function Xa() { return new Za(Wt(Wa)) } function Ja(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function tl(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function el(t) { return t && "?" !== t[0] ? "?" + t : t } let nl = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ factory: rl, token: t, providedIn: "root" }), t })(); function rl(t) { const e = Wt(Wa).location; return new il(Wt(Qa), e && e.origin || "") } const sl = new Dt("appBaseHref"); let il = (() => { class t extends nl { constructor(t, e) { if (super(), this._platformLocation = t, null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return Ja(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + el(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, r) { const s = this.prepareExternalUrl(n + el(r)); this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { const s = this.prepareExternalUrl(n + el(r)); this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Qa), Wt(sl, 8)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), ol = (() => { class t extends nl { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", null != e && (this._baseHref = e) } onPopState(t) { this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = Ja(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, r) { let s = this.prepareExternalUrl(n + el(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, r) { let s = this.prepareExternalUrl(n + el(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Qa), Wt(sl, 8)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), al = (() => { class t { constructor(t, e) { this._subject = new Mo, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = tl(cl(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + el(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, cl(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + el(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + el(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(nl), Wt(Qa)) }, t.normalizeQueryParams = el, t.joinWithSlash = Ja, t.stripTrailingSlash = tl, t.\u0275prov = ct({ factory: ll, token: t, providedIn: "root" }), t })(); function ll() { return new al(Wt(nl), Wt(Qa)) } function cl(t) { return t.replace(/\/index.html$/, "") } var ul = function (t) { return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t }({}); class hl { } let dl = (() => { class t extends hl { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function (t) { return function (t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = Co(e); if (n) return n; const r = e.split("-")[0]; if (n = Co(r), n) return n; if ("en" === r) return wo; throw new Error(`Missing locale data for the locale "${t}".`) }(t)[So.PluralCase] }(e || this.locale)(t)) { case ul.Zero: return "zero"; case ul.One: return "one"; case ul.Two: return "two"; case ul.Few: return "few"; case ul.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(Wt(ea)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), pl = (() => { class t { constructor(t, e, n, r) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = n, this._renderer = r, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (di(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass); t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass); t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + vt(t.item)); this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) { (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function (e) { return new (e || t)(_i(ro), _i(so), _i(Li), _i(Bi)) }, t.\u0275dir = de({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(); class fl { constructor(t, e, n, r) { this.$implicit = t, this.ngForOf = e, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let ml = (() => { class t { constructor(t, e, n) { this._viewContainer = t, this._template = e, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(t) { this._ngForOf = t, this._ngForOfDirty = !0 } set ngForTrackBy(t) { or() && null != t && "function" != typeof t && console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(t)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`), this._trackByFn = t } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(t) { t && (this._template = t) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (e) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${t = n, t.name || typeof t}'. NgFor only supports binding to Iterables such as Arrays.`) } } var t; if (this._differ) { const t = this._differ.diff(this._ngForOf); t && this._applyChanges(t) } } _applyChanges(t) { const e = []; t.forEachOperation((t, n, r) => { if (null == t.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new fl(null, this._ngForOf, -1, -1), null === r ? void 0 : r), s = new gl(t, n); e.push(s) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const s = this._viewContainer.get(n); this._viewContainer.move(s, r); const i = new gl(t, s); e.push(i) } }); for (let n = 0; n < e.length; n++)this._perViewChange(e[n].view, e[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const t = this._viewContainer.get(n); t.context.index = n, t.context.count = r, t.context.ngForOf = this._ngForOf } t.forEachIdentityChange(t => { this._viewContainer.get(t.currentIndex).context.$implicit = t.item }) } _perViewChange(t, e) { t.context.$implicit = e.item } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(_i(uo), _i(lo), _i(ro)) }, t.\u0275dir = de({ type: t, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), t })(); class gl { constructor(t, e) { this.record = t, this.view = e } } let yl = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new _l, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { vl("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { vl("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(_i(uo), _i(lo)) }, t.\u0275dir = de({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class _l { constructor() { this.$implicit = null, this.ngIf = null } } function vl(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${vt(e)}'.`) } let wl = (() => { class t { constructor(t, e, n) { this._ngEl = t, this._differs = e, this._renderer = n, this._ngStyle = null, this._differ = null } set ngStyle(t) { this._ngStyle = t, !this._differ && t && (this._differ = this._differs.find(t).create()) } ngDoCheck() { if (this._differ) { const t = this._differ.diff(this._ngStyle); t && this._applyChanges(t) } } _setStyle(t, e) { const [n, r] = t.split("."); null != (e = null != e && r ? `${e}${r}` : e) ? this._renderer.setStyle(this._ngEl.nativeElement, n, e) : this._renderer.removeStyle(this._ngEl.nativeElement, n) } _applyChanges(t) { t.forEachRemovedItem(t => this._setStyle(t.key, null)), t.forEachAddedItem(t => this._setStyle(t.key, t.currentValue)), t.forEachChangedItem(t => this._setStyle(t.key, t.currentValue)) } } return t.\u0275fac = function (e) { return new (e || t)(_i(Li), _i(so), _i(Bi)) }, t.\u0275dir = de({ type: t, selectors: [["", "ngStyle", ""]], inputs: { ngStyle: "ngStyle" } }), t })(), bl = (() => { class t { } return t.\u0275mod = ue({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [{ provide: hl, useClass: dl }] }), t })(); function Cl(t) { return "browser" === t } let Sl = (() => { class t { } return t.\u0275prov = ct({ token: t, providedIn: "root", factory: () => new xl(Wt(Wa), window, Wt(nr)) }), t })(); class xl { constructor(t, e, n) { this.document = t, this.window = e, this.errorHandler = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportScrollRestoration() ? [this.window.scrollX, this.window.scrollY] : [0, 0] } scrollToPosition(t) { this.supportScrollRestoration() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (this.supportScrollRestoration()) { const e = this.document.getElementById(t) || this.document.getElementsByName(t)[0]; e && this.scrollToElement(e) } } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], r - s[1]) } supportScrollRestoration() { try { if (!this.window || !this.window.scrollTo) return !1; const t = El(this.window.history) || El(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } } function El(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class kl extends class extends class { }{ constructor() { super() } supportsDOMEvents() { return !0 } }{ static makeCurrent() { var t; t = new kl, $a || ($a = t) } getProperty(t, e) { return t[e] } log(t) { window.console && window.console.log && window.console.log(t) } logGroup(t) { window.console && window.console.group && window.console.group(t) } logGroupEnd() { window.console && window.console.groupEnd && window.console.groupEnd() } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { return t.parentNode && t.parentNode.removeChild(t), t } getValue(t) { return t.value } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getHistory() { return window.history } getLocation() { return window.location } getBaseHref(t) { const e = Pl || (Pl = document.querySelector("base"), Pl) ? Pl.getAttribute("href") : null; return null == e ? null : (n = e, Tl || (Tl = document.createElement("a")), Tl.setAttribute("href", n), "/" === Tl.pathname.charAt(0) ? Tl.pathname : "/" + Tl.pathname); var n } resetBaseElement() { Pl = null } getUserAgent() { return window.navigator.userAgent } performanceNow() { return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime() } supportsCookies() { return !0 } getCookie(t) { return function (t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [r, s] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (r.trim() === e) return decodeURIComponent(s) } return null }(document.cookie, t) } } let Tl, Pl = null; const Ol = new Dt("TRANSITION_ID"), Al = [{ provide: Wo, useFactory: function (t, e, n) { return () => { n.get(Qo).donePromise.then(() => { const n = qa(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [Ol, Wa, ai], multi: !0 }]; class Ml { static init() { var t; t = new Ml, Ea = t } addToWindow(t) { Pt.getAngularTestability = (e, n = !0) => { const r = t.findTestabilityInTree(e, n); if (null == r) throw new Error("Could not find testability for element."); return r }, Pt.getAllAngularTestabilities = () => t.getAllTestabilities(), Pt.getAllAngularRootElements = () => t.getAllRootElements(), Pt.frameworkStabilizers || (Pt.frameworkStabilizers = []), Pt.frameworkStabilizers.push(t => { const e = Pt.getAllAngularTestabilities(); let n = e.length, r = !1; const s = function (e) { r = r || e, n--, 0 == n && t(r) }; e.forEach((function (t) { t.whenStable(s) })) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : n ? qa().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } const Il = new Dt("EventManagerPlugins"); let Rl = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let r = 0; r < n.length; r++) { const e = n[r]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error("No event manager plugin found for event " + t) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Il), Wt(pa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); class Nl { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const r = qa().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, n) } } let jl = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), Dl = (() => { class t extends jl { constructor(t) { super(), this._doc = t, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(t.head) } _addStylesToHost(t, e) { t.forEach(t => { const n = this._doc.createElement("style"); n.textContent = t, this._styleNodes.add(e.appendChild(n)) }) } addHost(t) { this._addStylesToHost(this._stylesSet, t), this._hostNodes.add(t) } removeHost(t) { this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach(e => this._addStylesToHost(t, e)) } ngOnDestroy() { this._styleNodes.forEach(t => qa().remove(t)) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Wa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const Fl = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Ll = /%COMP%/g; function Ul(t, e, n) { for (let r = 0; r < e.length; r++) { let s = e[r]; Array.isArray(s) ? Ul(t, s, n) : (s = s.replace(Ll, t), n.push(s)) } return n } function zl(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Hl = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Bl(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case ne.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new Vl(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case ne.Native: case ne.ShadowDom: return new $l(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = Ul(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Rl), Wt(Dl), Wt(Go)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); class Bl { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(Fl[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, r) { if (r) { e = r + ":" + e; const s = Fl[r]; s ? t.setAttributeNS(s, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const r = Fl[n]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, r) { r & Hi.DashCase ? t.style.setProperty(e, n, r & Hi.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & Hi.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, zl(n)) : this.eventManager.addEventListener(t, e, zl(n)) } } class Vl extends Bl { constructor(t, e, n, r) { super(t), this.component = n; const s = Ul(r + "-" + n.id, n.styles, []); e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(Ll, r + "-" + n.id), this.hostAttr = function (t) { return "_nghost-%COMP%".replace(Ll, t) }(r + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class $l extends Bl { constructor(t, e, n, r) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.component = r, this.shadowRoot = r.encapsulation === ne.ShadowDom ? n.attachShadow({ mode: "open" }) : n.createShadowRoot(), this.sharedStylesHost.addHost(this.shadowRoot); const s = Ul(r.id, r.styles, []); for (let i = 0; i < s.length; i++) { const t = document.createElement("style"); t.textContent = s[i], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let ql = (() => { class t extends Nl { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Wa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const Wl = ["alt", "control", "meta", "shift"], Ql = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Gl = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, Kl = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let Zl = (() => { class t extends Nl { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, r) { const s = t.parseEventName(n), i = t.eventCallback(s.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => qa().onAndCancel(e, s.domEventName, i)) } static parseEventName(e) { const n = e.toLowerCase().split("."), r = n.shift(); if (0 === n.length || "keydown" !== r && "keyup" !== r) return null; const s = t._normalizeKey(n.pop()); let i = ""; if (Wl.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), i += t + ".") }), i += s, 0 != n.length || 0 === s.length) return null; const o = {}; return o.domEventName = r, o.fullKey = i, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && Gl.hasOwnProperty(e) && (e = Gl[e])) } return Ql[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), Wl.forEach(r => { r != n && (0, Kl[r])(t) && (e += r + ".") }), e += n, e } static eventCallback(e, n, r) { return s => { t.getEventFullKey(s) === e && r.runGuarded(() => n(s)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Wa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const Yl = Pa(Ua, "browser", [{ provide: Xo, useValue: "browser" }, { provide: Yo, useValue: function () { kl.makeCurrent(), Ml.init() }, multi: !0 }, { provide: Wa, useFactory: function () { return function (t) { Oe = t }(document), document }, deps: [] }]), Xl = [[], { provide: Gs, useValue: "root" }, { provide: nr, useFactory: function () { return new nr }, deps: [] }, { provide: Il, useClass: ql, multi: !0, deps: [Wa, pa, Xo] }, { provide: Il, useClass: Zl, multi: !0, deps: [Wa] }, [], { provide: Hl, useClass: Hl, deps: [Rl, Dl, Go] }, { provide: zi, useExisting: Hl }, { provide: jl, useExisting: Dl }, { provide: Dl, useClass: Dl, deps: [Wa] }, { provide: ba, useClass: ba, deps: [pa] }, { provide: Rl, useClass: Rl, deps: [Il, pa] }, []]; let Jl = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: Go, useValue: e.appId }, { provide: Ol, useExisting: Go }, Al] } } } return t.\u0275mod = ue({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t)(Wt(t, 12)) }, providers: Xl, imports: [bl, Ha] }), t })(); "undefined" != typeof window && window; class tc { } function ec(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function nc(t, e = null) { return { type: 4, styles: e, timings: t } } function rc(t, e = null) { return { type: 3, steps: t, options: e } } function sc(t, e = null) { return { type: 2, steps: t, options: e } } function ic(t) { return { type: 6, styles: t, offset: null } } function oc(t) { return { type: 5, steps: t } } function ac(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function lc(t = null) { return { type: 9, options: t } } function cc(t, e, n = null) { return { type: 11, selector: t, animation: e, options: n } } function uc(t, e) { return { type: 12, timings: t, animation: e } } function hc(t) { Promise.resolve(null).then(t) } class dc { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { hc(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { } setPosition(t) { } getPosition() { return 0 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class pc { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, r = 0; const s = this.players.length; 0 == s ? hc(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == s && this._onFinish() }), t.onDestroy(() => { ++n == s && this._onDestroy() }), t.onStart(() => { ++r == s && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { let t = 0; return this.players.forEach(e => { const n = e.getPosition(); t = Math.min(n, t) }), t } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function fc() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function mc(t) { switch (t.length) { case 0: return new dc; case 1: return t[0]; default: return new pc(t) } } function gc(t, e, n, r, s = {}, i = {}) { const o = [], a = []; let l = -1, c = null; if (r.forEach(t => { const n = t.offset, r = n == l, u = r && c || {}; Object.keys(t).forEach(n => { let r = n, a = t[n]; if ("offset" !== n) switch (r = e.normalizePropertyName(r, o), a) { case "!": a = s[n]; break; case "*": a = i[n]; break; default: a = e.normalizeStyleValue(n, r, a, o) }u[r] = a }), r || a.push(u), c = u, l = n }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return a } function yc(t, e, n, r) { switch (e) { case "start": t.onStart(() => r(n && _c(n, "start", t))); break; case "done": t.onDone(() => r(n && _c(n, "done", t))); break; case "destroy": t.onDestroy(() => r(n && _c(n, "destroy", t))) } } function _c(t, e, n) { const r = n.totalTime, s = vc(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == r ? t.totalTime : r, !!n.disabled), i = t._data; return null != i && (s._data = i), s } function vc(t, e, n, r, s = "", i = 0, o) { return { element: t, triggerName: e, fromState: n, toState: r, phaseName: s, totalTime: i, disabled: !!o } } function wc(t, e, n) { let r; return t instanceof Map ? (r = t.get(e), r || t.set(e, r = n)) : (r = t[e], r || (r = t[e] = n)), r } function bc(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let Cc = (t, e) => !1, Sc = (t, e) => !1, xc = (t, e, n) => []; const Ec = fc(); (Ec || "undefined" != typeof Element) && (Cc = (t, e) => t.contains(e), Sc = (() => { if (Ec || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : Sc } })(), xc = (t, e, n) => { let r = []; if (n) r.push(...t.querySelectorAll(e)); else { const n = t.querySelector(e); n && r.push(n) } return r }); let kc = null, Tc = !1; function Pc(t) { kc || (kc = ("undefined" != typeof document ? document.body : null) || {}, Tc = !!kc.style && "WebkitAppearance" in kc.style); let e = !0; return kc.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in kc.style, !e && Tc) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in kc.style), e } const Oc = Sc, Ac = Cc, Mc = xc; function Ic(t) { const e = {}; return Object.keys(t).forEach(n => { const r = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[r] = t[n] }), e } let Rc = (() => { class t { validateStyleProperty(t) { return Pc(t) } matchesElement(t, e) { return Oc(t, e) } containsElement(t, e) { return Ac(t, e) } query(t, e, n) { return Mc(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, r, s, i = [], o) { return new dc(n, r) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), Nc = (() => { class t { } return t.NOOP = new Rc, t })(); function jc(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : Dc(parseFloat(e[1]), e[2]) } function Dc(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function Fc(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let r, s = 0, i = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; r = Dc(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (s = Dc(parseFloat(o), n[4])); const a = n[5]; a && (i = a) } else r = t; if (!n) { let n = !1, i = e.length; r < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(i, 0, `The provided timing value "${t}" is invalid.`) } return { duration: r, delay: s, easing: i } }(t, e, n) } function Lc(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function Uc(t, e, n = {}) { if (e) for (let r in t) n[r] = t[r]; else Lc(t, n); return n } function zc(t, e, n) { return n ? e + ":" + n + ";" : "" } function Hc(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const r = t.style.item(n); e += zc(0, r, t.style.getPropertyValue(r)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += zc(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function Bc(t, e, n) { t.style && (Object.keys(e).forEach(r => { const s = Zc(r); n && !n.hasOwnProperty(r) && (n[r] = t.style[s]), t.style[s] = e[r] }), fc() && Hc(t)) } function Vc(t, e) { t.style && (Object.keys(e).forEach(e => { const n = Zc(e); t.style[n] = "" }), fc() && Hc(t)) } function $c(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : sc(t) : t } const qc = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function Wc(t) { let e = []; if ("string" == typeof t) { let n; for (; n = qc.exec(t);)e.push(n[1]); qc.lastIndex = 0 } return e } function Qc(t, e, n) { const r = t.toString(), s = r.replace(qc, (t, r) => { let s = e[r]; return e.hasOwnProperty(r) || (n.push("Please provide a value for the animation param " + r), s = ""), s.toString() }); return s == r ? t : s } function Gc(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const Kc = /-+([a-z0-9])/g; function Zc(t) { return t.replace(Kc, (...t) => t[1].toUpperCase()) } function Yc(t, e) { return 0 === t || 0 === e } function Xc(t, e, n) { const r = Object.keys(n); if (r.length && e.length) { let i = e[0], o = []; if (r.forEach(t => { i.hasOwnProperty(t) || o.push(t), i[t] = n[t] }), o.length) for (var s = 1; s < e.length; s++) { let n = e[s]; o.forEach((function (e) { n[e] = tu(t, e) })) } } return e } function Jc(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error("Unable to resolve animation metadata node #" + e.type) } } function tu(t, e) { return window.getComputedStyle(t)[e] } function eu(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const r = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof r) return void e.push(r); t = r } const r = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == r || r.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const s = r[1], i = r[2], o = r[3]; e.push(su(s, o)), "<" != i[0] || "*" == s && "*" == o || e.push(su(o, s)) }(t, n, e)) : n.push(t), n } const nu = new Set(["true", "1"]), ru = new Set(["false", "0"]); function su(t, e) { const n = nu.has(t) || ru.has(t), r = nu.has(e) || ru.has(e); return (s, i) => { let o = "*" == t || t == s, a = "*" == e || e == i; return !o && n && "boolean" == typeof s && (o = s ? nu.has(t) : ru.has(t)), !a && r && "boolean" == typeof i && (a = i ? nu.has(e) : ru.has(e)), o && a } } const iu = new RegExp("s*:selfs*,?", "g"); function ou(t, e, n) { return new au(t).build(e, n) } class au { constructor(t) { this._driver = t } build(t, e) { const n = new lu(e); return this._resetContextStyleTimingState(n), Jc(this, $c(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, r = e.depCount = 0; const s = [], i = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, r = n.name; r.toString().split(/\s*,\s*/).forEach(t => { n.name = t, s.push(this.visitState(n, e)) }), n.name = r } else if (1 == t.type) { const s = this.visitTransition(t, e); n += s.queryCount, r += s.depCount, i.push(s) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: i, queryCount: n, depCount: r, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (n.containsDynamicStyles) { const s = new Set, i = r || {}; if (n.styles.forEach(t => { if (cu(t)) { const e = t; Object.keys(e).forEach(t => { Wc(e[t]).forEach(t => { i.hasOwnProperty(t) || s.add(t) }) }) } }), s.size) { const n = Gc(s.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = Jc(this, $c(t.animation), e); return { type: 1, matchers: eu(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: uu(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => Jc(this, t, e)), options: uu(t.options) } } visitGroup(t, e) { const n = e.currentTime; let r = 0; const s = t.steps.map(t => { e.currentTime = n; const s = Jc(this, t, e); return r = Math.max(r, e.currentTime), s }); return e.currentTime = r, { type: 3, steps: s, options: uu(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return hu(Fc(t, e).duration, 0, ""); const r = t; if (r.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = hu(0, 0, ""); return t.dynamic = !0, t.strValue = r, t } return n = n || Fc(r, e), hu(n.duration, n.delay, n.easing) }(t.timings, e.errors); let r; e.currentAnimateTimings = n; let s = t.styles ? t.styles : ic({}); if (5 == s.type) r = this.visitKeyframes(s, e); else { let s = t.styles, i = !1; if (!s) { i = !0; const t = {}; n.easing && (t.easing = n.easing), s = ic(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(s, e); o.isEmptyStep = i, r = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: r, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? "*" == t ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let r = !1, s = null; return n.forEach(t => { if (cu(t)) { const e = t, n = e.easing; if (n && (s = n, delete e.easing), !r) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: n, easing: s, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let r = e.currentTime, s = e.currentTime; n && s > 0 && (s -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const i = e.collectedStyles[e.currentQuerySelector], o = i[n]; let a = !0; o && (s != r && s >= o.startTime && r <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${r}ms"`), a = !1), s = o.startTime), a && (i[n] = { startTime: s, endTime: r }), e.options && function (t, e, n) { const r = e.params || {}, s = Wc(t); s.length && s.forEach(t => { r.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let r = 0; const s = []; let i = !1, o = !1, a = 0; const l = t.steps.map(t => { const n = this._makeStyleAst(t, e); let l = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (cu(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (cu(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != l && (r++, c = n.offset = l), o = o || c < 0 || c > 1, i = i || c < a, a = c, s.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), i && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let u = 0; r > 0 && r < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == r && (u = 1 / (c - 1)); const h = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, r) => { const i = u > 0 ? r == h ? 1 : u * r : s[r], o = i * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = i, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: Jc(this, $c(t.animation), e), options: uu(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: uu(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: uu(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [s, i] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(iu, "")), [t = t.replace(/@\*/g, ".ng-trigger").replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ".ng-animating"), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + s : s, wc(e.collectedStyles, e.currentQuerySelector, {}); const o = Jc(this, $c(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: s, limit: r.limit || 0, optional: !!r.optional, includeSelf: i, animation: o, originalSelector: t.selector, options: uu(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : Fc(t.timings, e.errors, !0); return { type: 12, animation: Jc(this, $c(t.animation), e), timings: n, options: null } } } class lu { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function cu(t) { return !Array.isArray(t) && "object" == typeof t } function uu(t) { var e; return t ? (t = Lc(t)).params && (t.params = (e = t.params) ? Lc(e) : null) : t = {}, t } function hu(t, e, n) { return { duration: t, delay: e, easing: n } } function du(t, e, n, r, s, i, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: r, duration: s, delay: i, totalTime: s + i, easing: o, subTimeline: a } } class pu { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const fu = new RegExp(":enter", "g"), mu = new RegExp(":leave", "g"); function gu(t, e, n, r, s, i = {}, o = {}, a, l, c = []) { return (new yu).buildKeyframes(t, e, n, r, s, i, o, a, l, c) } class yu { buildKeyframes(t, e, n, r, s, i, o, a, l, c = []) { l = l || new pu; const u = new vu(t, e, l, r, s, c, []); u.options = a, u.currentTimeline.setStyles([i], null, u.errors, a), Jc(this, n, u); const h = u.timelines.filter(t => t.containsAnimation()); if (h.length && Object.keys(o).length) { const t = h[h.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, u.errors, a) } return h.length ? h.map(t => t.buildKeyframes()) : [du(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const r = e.createSubContext(t.options), s = e.currentTimeline.currentTime, i = this._visitSubInstructions(n, r, r.options); s != i && e.transformIntoNewTimeline(i) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let r = e.currentTimeline.currentTime; const s = null != n.duration ? jc(n.duration) : null, i = null != n.delay ? jc(n.delay) : null; return 0 !== s && t.forEach(t => { const n = e.appendInstructionToTimeline(t, s, i); r = Math.max(r, n.duration + n.delay) }), r } visitReference(t, e) { e.updateOptions(t.options, !0), Jc(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let r = e; const s = t.options; if (s && (s.params || s.delay) && (r = e.createSubContext(s), r.transformIntoNewTimeline(), null != s.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = _u); const t = jc(s.delay); r.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => Jc(this, t, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > n && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let r = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? jc(t.options.delay) : 0; t.steps.forEach(i => { const o = e.createSubContext(t.options); s && o.delayNextStep(s), Jc(this, i, o), r = Math.max(r, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return Fc(e.params ? Qc(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; n.delay && (e.incrementTime(n.delay), r.snapshotCurrentStyles()); const s = t.style; 5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(n.duration), this.visitStyle(s, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, r = e.currentAnimateTimings; !r && n.getCurrentStyleProperties().length && n.forwardFrame(); const s = r && r.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(s) : n.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, r = e.currentTimeline.duration, s = n.duration, i = e.createSubContext().currentTimeline; i.easing = n.easing, t.styles.forEach(t => { i.forwardTime((t.offset || 0) * s), i.setStyles(t.styles, t.easing, e.errors, e.options), i.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(i), e.transformIntoNewTimeline(r + s), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, r = t.options || {}, s = r.delay ? jc(r.delay) : 0; s && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = _u); let i = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, r) => { e.currentQueryIndex = r; const o = e.createSubContext(t.options, n); s && o.delayNextStep(s), n === e.element && (a = o.currentTimeline), Jc(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), i = Math.max(i, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(i), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, r = e.currentTimeline, s = t.timings, i = Math.abs(s.duration), o = i * (e.currentQueryTotal - 1); let a = i * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; Jc(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = r.currentTime - c + (r.startTime - n.currentTimeline.startTime) } } const _u = {}; class vu { constructor(t, e, n, r, s, i, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = r, this._leaveClassName = s, this.errors = i, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = _u, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new wu(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let r = this.options; null != n.duration && (r.duration = jc(n.duration)), null != n.delay && (r.delay = jc(n.delay)); const s = n.params; if (s) { let t = r.params; t || (t = this.options.params = {}), Object.keys(s).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = Qc(s[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const r = e || this.element, s = new vu(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, n || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = _u, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, s = new bu(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(s), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, r, s, i) { let o = []; if (r && o.push(this.element), t.length > 0) { t = (t = t.replace(fu, "." + this._enterClassName)).replace(mu, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return s || 0 != o.length || i.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class wu { constructor(t, e, n, r) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new wu(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || "*", this._currentKeyframe[t] = "*" }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, r) { e && (this._previousKeyframe.easing = e); const s = r && r.params || {}, i = function (t, e) { const n = {}; let r; return t.forEach(t => { "*" === t ? (r = r || Object.keys(e), r.forEach(t => { n[t] = "*" })) : Uc(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(i).forEach(t => { const e = Qc(i[t], s, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : "*"), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], r = t._styleSummary[e]; (!n || r.time > n.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((s, i) => { const o = Uc(s, !0); Object.keys(o).forEach(n => { const r = o[n]; "!" == r ? t.add(n) : "*" == r && e.add(n) }), n || (o.offset = i / this.duration), r.push(o) }); const s = t.size ? Gc(t.values()) : [], i = e.size ? Gc(e.values()) : []; if (n) { const t = r[0], e = Lc(t); t.offset = 0, e.offset = 1, r = [t, e] } return du(this.element, r, s, i, this.duration, this.startTime, this.easing, !1) } } class bu extends wu { constructor(t, e, n, r, s, i, o = !1) { super(t, e, i.delay), this.element = e, this.keyframes = n, this.preStyleProps = r, this.postStyleProps = s, this._stretchStartingKeyframe = o, this.timings = { duration: i.duration, delay: i.delay, easing: i.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [], i = n + e, o = e / i, a = Uc(t[0], !1); a.offset = 0, s.push(a); const l = Uc(t[0], !1); l.offset = Cu(o), s.push(l); const c = t.length - 1; for (let r = 1; r <= c; r++) { let o = Uc(t[r], !1); o.offset = Cu((e + o.offset * n) / i), s.push(o) } n = i, e = 0, r = "", t = s } return du(this.element, t, this.preStyleProps, this.postStyleProps, n, e, r, !0) } } function Cu(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class Su { } class xu extends Su { normalizePropertyName(t, e) { return Zc(t) } normalizeStyleValue(t, e, n, r) { let s = ""; const i = n.toString().trim(); if (Eu[e] && 0 !== n && "0" !== n) if ("number" == typeof n) s = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && r.push(`Please provide a CSS unit value for ${t}:${n}`) } return i + s } } const Eu = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function ku(t, e, n, r, s, i, o, a, l, c, u, h, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: s, fromState: n, fromStyles: i, toState: r, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: h, errors: d } } const Tu = {}; class Pu { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, r) { return function (t, e, n, r, s) { return t.some(t => t(e, n, r, s)) }(this.ast.matchers, t, e, n, r) } buildStyles(t, e, n) { const r = this._stateStyles["*"], s = this._stateStyles[t], i = r ? r.buildStyles(e, n) : {}; return s ? s.buildStyles(e, n) : i } build(t, e, n, r, s, i, o, a, l, c) { const u = [], h = this.ast.options && this.ast.options.params || Tu, d = this.buildStyles(n, o && o.params || Tu, u), p = a && a.params || Tu, f = this.buildStyles(r, p, u), m = new Set, g = new Map, y = new Map, _ = "void" === r, v = { params: Object.assign(Object.assign({}, h), p) }, w = c ? [] : gu(t, e, this.ast.animation, s, i, d, f, v, l, u); let b = 0; if (w.forEach(t => { b = Math.max(t.duration + t.delay, b) }), u.length) return ku(e, this._triggerName, n, r, _, d, f, [], [], g, y, b, u); w.forEach(t => { const n = t.element, r = wc(g, n, {}); t.preStyleProps.forEach(t => r[t] = !0); const s = wc(y, n, {}); t.postStyleProps.forEach(t => s[t] = !0), n !== e && m.add(n) }); const C = Gc(m.values()); return ku(e, this._triggerName, n, r, _, d, f, w, C, g, y, b) } } class Ou { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, r = Lc(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (r[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const s = t; Object.keys(s).forEach(t => { let i = s[t]; i.length > 1 && (i = Qc(i, r, e)), n[t] = i }) } }), n } } class Au { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new Ou(t.style, t.options && t.options.params || {}) }), Mu(this.states, "true", "1"), Mu(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new Pu(t, e, this.states)) }), this.fallbackTransition = new Pu(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, r) { return this.transitionFactories.find(s => s.match(t, e, n, r)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function Mu(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const Iu = new pu; class Ru { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], r = ou(this._driver, e, n); if (n.length) throw new Error("Unable to build the animation due to the following errors: " + n.join("\n")); this._animations[t] = r } _buildPlayer(t, e, n) { const r = t.element, s = gc(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(r, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const r = [], s = this._animations[t]; let i; const o = new Map; if (s ? (i = gu(this._driver, e, s, "ng-enter", "ng-leave", {}, {}, n, Iu, r), i.forEach(t => { const e = wc(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), i = []), r.length) throw new Error("Unable to create the animation due to the following errors: " + r.join("\n")); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, "*") }) }); const a = mc(i.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error("Unable to find the timeline player referenced by " + t); return e } listen(t, e, n, r) { const s = vc(e, "", "", ""); return yc(this._getPlayer(t), n, s, r), () => { } } command(t, e, n, r) { if ("register" == n) return void this.register(t, r[0]); if ("create" == n) return void this.create(t, e, r[0] || {}); const s = this._getPlayer(t); switch (n) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const Nu = [], ju = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, Du = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class Fu { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (r = n ? t.value : t) ? r : null, n) { const e = Lc(t); delete e.value, this.options = e } else this.options = {}; var r; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const Lu = new Fu("void"); class Uu { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, Wu(e, this._hostClassName) } listen(t, e, n, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (s = n) && "done" != s) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var s; const i = wc(this._elementListeners, t, []), o = { name: e, phase: n, callback: r }; i.push(o); const a = wc(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (Wu(t, "ng-trigger"), Wu(t, "ng-trigger-" + e), a[e] = Lu), () => { this._engine.afterFlush(() => { const t = i.indexOf(o); t >= 0 && i.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, r = !0) { const s = this._getTrigger(e), i = new Hu(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (Wu(t, "ng-trigger"), Wu(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new Fu(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = Lu), "void" !== l.value && a.value === l.value) { if (!function (t, e) { const n = Object.keys(t), r = Object.keys(e); if (n.length != r.length) return !1; for (let s = 0; s < n.length; s++) { const r = n[s]; if (!e.hasOwnProperty(r) || t[r] !== e[r]) return !1 } return !0 }(a.params, l.params)) { const e = [], n = s.matchStyles(a.value, a.params, e), r = s.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { Vc(t, n), Bc(t, r) }) } return } const c = wc(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let u = s.matchTransition(a.value, l.value, t, l.params), h = !1; if (!u) { if (!r) return; u = s.fallbackTransition, h = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: u, fromState: a, toState: l, player: i, isFallbackTransition: h }), h || (Wu(t, "ng-animate-queued"), i.onStart(() => { Qu(t, "ng-animate-queued") })), i.onDone(() => { let e = this.players.indexOf(i); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(i); t >= 0 && n.splice(t, 1) } }), this.players.push(i), c.push(i), i } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const n = this._engine.driver.query(t, ".ng-trigger", !0); n.forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => n.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, n, r) { const s = this._engine.statesByElement.get(t); if (s) { const i = []; if (Object.keys(s).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, "void", r); n && i.push(n) } }), i.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && mc(i).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t); if (e) { const n = new Set; e.forEach(e => { const r = e.name; if (n.has(r)) return; n.add(r); const s = this._triggers[r].fallbackTransition, i = this._engine.statesByElement.get(t)[r] || Lu, o = new Fu("void"), a = new Hu(this.id, r, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: r, transition: s, fromState: i, toState: o, player: a, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) r = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { r = !0; break } } } if (this.prepareLeaveAnimationListeners(t), r) n.markElementAsRemoved(this.id, t, !1, e); else { const r = t.__ng_removed; r && r !== ju || (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } } insertNode(t, e) { Wu(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const r = n.player; if (r.destroyed) return; const s = n.element, i = this._elementListeners.get(s); i && i.forEach(e => { if (e.name == n.triggerName) { const r = vc(s, n.triggerName, n.fromState.value, n.toState.value); r._data = t, yc(n.player, e.phase, r, e.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, r = e.transition.ast.depCount; return 0 == n || 0 == r ? n - r : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class zu { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new Uu(t, e, this); return e.parentNode ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let r = !1; for (let s = n; s >= 0; s--)if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let r = this._namespaceLookup[t]; r && r.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let r = 0; r < t.length; r++) { const s = n[t[r]].namespaceId; if (s) { const t = this._fetchNamespace(s); t && e.add(t) } } } return e } trigger(t, e, n, r) { if (Bu(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, n, r), !0 } return !1 } insertNode(t, e, n, r) { if (!Bu(e)) return; const s = e.__ng_removed; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const r = this._fetchNamespace(t); r && r.insertNode(e, n) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Wu(t, "ng-animate-disabled")) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Qu(t, "ng-animate-disabled")) } removeNode(t, e, n, r) { if (Bu(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, n, r) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: r, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, r, s) { return Bu(e) ? this._fetchNamespace(t).listen(e, n, r, s) : () => { } } _buildInstruction(t, e, n, r, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, r, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, ".ng-trigger", !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ".ng-animating", !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return mc(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = ju, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ".ng-animate-disabled") && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)Wu(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? mc(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error("Unable to process animations due to the following failed trigger transitions\n " + t.join("\n")) } _flushAnimations(t, e) { const n = new pu, r = [], s = new Map, i = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const u = this.bodyNode, h = Array.from(this.statesByElement.keys()), d = qu(h, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = "ng-enter" + f++; p.set(e, n), t.forEach(t => Wu(t, n)) }); const m = [], g = new Set, y = new Set; for (let A = 0; A < this.collectedLeaveElements.length; A++) { const t = this.collectedLeaveElements[A], e = t.__ng_removed; e && e.setForRemoval && (m.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : y.add(t)) } const _ = new Map, v = qu(h, Array.from(g)); v.forEach((t, e) => { const n = "ng-leave" + f++; _.set(e, n), t.forEach(t => Wu(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => Qu(t, n)) }), v.forEach((t, e) => { const n = _.get(e); t.forEach(t => Qu(t, n)) }), m.forEach(t => { this.processLeaveNode(t) }) }); const w = [], b = []; for (let A = this._namespaceList.length - 1; A >= 0; A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(t => { const e = t.player, s = t.element; if (w.push(e), this.collectedEnterElements.length) { const t = s.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !u || !this.driver.containsElement(u, s), h = _.get(s), d = p.get(s), f = this._buildInstruction(t, n, d, h, c); if (f.errors && f.errors.length) b.push(f); else { if (c) return e.onStart(() => Vc(s, f.fromStyles)), e.onDestroy(() => Bc(s, f.toStyles)), void r.push(e); if (t.isFallbackTransition) return e.onStart(() => Vc(s, f.fromStyles)), e.onDestroy(() => Bc(s, f.toStyles)), void r.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(s, f.timelines), i.push({ instruction: f, player: e, element: s }), f.queriedElements.forEach(t => wc(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = a.get(e); t || a.set(e, t = new Set), n.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let r = l.get(e); r || l.set(e, r = new Set), n.forEach(t => r.add(t)) }) } }); if (b.length) { const t = []; b.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), w.forEach(t => t.destroy()), this.reportError(t) } const C = new Map, S = new Map; i.forEach(t => { const e = t.element; n.has(e) && (S.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, C)) }), r.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { wc(C, e, []).push(t), t.destroy() }) }); const x = m.filter(t => Ku(t, a, l)), E = new Map; $u(E, this.driver, y, l, "*").forEach(t => { Ku(t, a, l) && x.push(t) }); const k = new Map; d.forEach((t, e) => { $u(k, this.driver, new Set(t), a, "!") }), x.forEach(t => { const e = E.get(t), n = k.get(t); E.set(t, Object.assign(Object.assign({}, e), n)) }); const T = [], P = [], O = {}; i.forEach(t => { const { element: e, player: i, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return i.onDestroy(() => Bc(e, o.toStyles)), i.disabled = !0, i.overrideTotalTime(o.totalTime), void r.push(i); let t = O; if (S.size > 1) { let n = e; const r = []; for (; n = n.parentNode;) { const e = S.get(n); if (e) { t = e; break } r.push(n) } r.forEach(e => S.set(e, t)) } const n = this._buildAnimation(i.namespaceId, o, C, s, k, E); if (i.setRealPlayer(n), t === O) T.push(i); else { const e = this.playersByElement.get(t); e && e.length && (i.parentPlayer = mc(e)), r.push(i) } } else Vc(e, o.fromStyles), i.onDestroy(() => Bc(e, o.toStyles)), P.push(i), c.has(e) && r.push(i) }), P.forEach(t => { const e = s.get(t.element); if (e && e.length) { const n = mc(e); t.setRealPlayer(n) } }), r.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let A = 0; A < m.length; A++) { const t = m[A], e = t.__ng_removed; if (Qu(t, "ng-leave"), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let r = this.driver.query(t, ".ng-animating", !0); for (let t = 0; t < r.length; t++) { let e = o.get(r[t]); e && e.length && n.push(...e) } } const r = n.filter(t => !t.destroyed); r.length ? Gu(this, t, r) : this.processLeaveNode(t) } return m.length = 0, T.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), T } elementContainsData(t, e) { let n = !1; const r = e.__ng_removed; return r && r.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, r, s) { let i = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (i = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !s || "void" == s; e.forEach(e => { e.queued || (t || e.triggerName == r) && i.push(e) }) } } return (n || r) && (i = i.filter(t => !(n && n != t.namespaceId || r && r != t.triggerName))), i } _beforeAnimationBuild(t, e, n) { const r = e.element, s = e.isRemovalTransition ? void 0 : t, i = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== r, l = wc(n, t, []); this._getPreviousPlayers(t, a, s, i, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } Vc(r, e.fromStyles) } _buildAnimation(t, e, n, r, s, i) { const o = e.triggerName, a = e.element, l = [], c = new Set, u = new Set, h = e.timelines.map(e => { const h = e.element; c.add(h); const d = h.__ng_removed; if (d && d.removedBeforeQueried) return new dc(e.duration, e.delay); const p = h !== a, f = function (t) { const e = []; return function t(e, n) { for (let r = 0; r < e.length; r++) { const s = e[r]; s instanceof pc ? t(s.players, n) : n.push(s) } }(t, e), e }((n.get(h) || Nu).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === h), m = s.get(h), g = i.get(h), y = gc(0, this._normalizer, 0, e.keyframes, m, g), _ = this._buildPlayer(e, y, f); if (e.subTimeline && r && u.add(h), p) { const e = new Hu(t, o, h); e.setRealPlayer(_), l.push(e) } return _ }); l.forEach(t => { wc(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let r; if (t instanceof Map) { if (r = t.get(e), r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && t.delete(e) } } else if (r = t[e], r) { if (r.length) { const t = r.indexOf(n); r.splice(t, 1) } 0 == r.length && delete t[e] } return r }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => Wu(t, "ng-animating")); const d = mc(h); return d.onDestroy(() => { c.forEach(t => Qu(t, "ng-animating")), Bc(a, e.toStyles) }), u.forEach(t => { wc(r, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new dc(t.duration, t.delay) } } class Hu { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new dc, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => yc(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { wc(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Bu(t) { return t && 1 === t.nodeType } function Vu(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function $u(t, e, n, r, s) { const i = []; n.forEach(t => i.push(Vu(t))); const o = []; r.forEach((n, r) => { const i = {}; n.forEach(t => { const n = i[t] = e.computeStyle(r, t, s); n && 0 != n.length || (r.__ng_removed = Du, o.push(r)) }), t.set(r, i) }); let a = 0; return n.forEach(t => Vu(t, i[a++])), o } function qu(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const r = new Set(e), s = new Map; return e.forEach(t => { const e = function t(e) { if (!e) return 1; let i = s.get(e); if (i) return i; const o = e.parentNode; return i = n.has(o) ? o : r.has(o) ? 1 : t(o), s.set(e, i), i }(t); 1 !== e && n.get(e).push(t) }), n } function Wu(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function Qu(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function Gu(t, e, n) { mc(n).onDone(() => t.processLeaveNode(e)) } function Ku(t, e, n) { const r = n.get(t); if (!r) return !1; let s = e.get(t); return s ? r.forEach(t => s.add(t)) : e.set(t, r), n.delete(t), !0 } class Zu { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new zu(t, e, n), this._timelineEngine = new Ru(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, r, s) { const i = t + "-" + r; let o = this._triggerCache[i]; if (!o) { const t = [], e = ou(this._driver, s, t); if (t.length) throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new Au(t, e) }(r, e), this._triggerCache[i] = o } this._transitionEngine.registerTrigger(e, r, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, r) { this._transitionEngine.insertNode(t, e, n, r) } onRemove(t, e, n, r) { this._transitionEngine.removeNode(t, e, r || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, r) { if ("@" == n.charAt(0)) { const [t, s] = bc(n); this._timelineEngine.command(t, e, s, r) } else this._transitionEngine.trigger(t, e, n, r) } listen(t, e, n, r, s) { if ("@" == n.charAt(0)) { const [t, r] = bc(n); return this._timelineEngine.listen(t, e, r, s) } return this._transitionEngine.listen(t, e, n, r, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function Yu(t, e) { let n = null, r = null; return Array.isArray(e) && e.length ? (n = Ju(e[0]), e.length > 1 && (r = Ju(e[e.length - 1]))) : e && (n = Ju(e)), n || r ? new Xu(t, n, r) : null } let Xu = (() => { class t { constructor(e, n, r) { this._element = e, this._startStyles = n, this._endStyles = r, this._state = 0; let s = t.initialStylesByElement.get(e); s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && Bc(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Bc(this._element, this._initialStyles), this._endStyles && (Bc(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (Vc(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Vc(this._element, this._endStyles), this._endStyles = null), Bc(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function Ju(t) { let e = null; const n = Object.keys(t); for (let r = 0; r < n.length; r++) { const s = n[r]; th(s) && (e = e || {}, e[s] = t[s]) } return e } function th(t) { return "display" === t || "position" === t } class eh { constructor(t, e, n, r, s, i, o) { this._element = t, this._name = e, this._duration = n, this._delay = r, this._easing = s, this._fillMode = i, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = ah(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let r = 0; r < t.length; r++)"," === t.charAt(r) && n++ }(n), e = `${n}, ${e}`), oh(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), ih(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { nh(this._element, this._name, "paused") } resume() { nh(this._element, this._name, "running") } setPosition(t) { const e = rh(this._element, this._name); this._position = t * this._duration, oh(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), ih(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = ah(t, "").split(","), r = sh(n, e); r >= 0 && (n.splice(r, 1), oh(t, "", n.join(","))) }(this._element, this._name)) } } function nh(t, e, n) { oh(t, "PlayState", n, rh(t, e)) } function rh(t, e) { const n = ah(t, ""); return n.indexOf(",") > 0 ? sh(n.split(","), e) : sh([n], e) } function sh(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function ih(t, e, n) { n ? t.removeEventListener("animationend", e) : t.addEventListener("animationend", e) } function oh(t, e, n, r) { const s = "animation" + e; if (null != r) { const e = t.style[s]; if (e.length) { const t = e.split(","); t[r] = n, n = t.join(",") } } t.style[s] = n } function ah(t, e) { return t.style["animation" + e] } class lh { constructor(t, e, n, r, s, i, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = r, this._delay = s, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this.currentSnapshot = {}, this._state = 0, this.easing = i || "linear", this.totalTime = r + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new eh(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : tu(this.element, n)) }) } this.currentSnapshot = t } } class ch extends dc { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = Ic(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class uh { constructor() { this._count = 0, this._head = document.querySelector("head"), this._warningIssued = !1 } validateStyleProperty(t) { return Pc(t) } matchesElement(t, e) { return Oc(t, e) } containsElement(t, e) { return Ac(t, e) } query(t, e, n) { return Mc(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => Ic(t)); let r = `@keyframes ${e} {\n`, s = ""; n.forEach(t => { s = " "; const e = parseFloat(t.offset); r += `${s}${100 * e}% {\n`, s += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (r += `${s}animation-timing-function: ${n};\n`)); default: return void (r += `${s}${e}: ${n};\n`) } }), r += s + "}\n" }), r += "}\n"; const i = document.createElement("style"); return i.innerHTML = r, i } animate(t, e, n, r, s, i = [], o) { o && this._notifyFaultyScrubber(); const a = i.filter(t => t instanceof lh), l = {}; Yc(n, r) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = Xc(t, e, l)); if (0 == n) return new ch(t, c); const u = "gen_css_kf_" + this._count++, h = this.buildKeyframeElement(t, u, e); document.querySelector("head").appendChild(h); const d = Yu(t, e), p = new lh(t, e, u, n, r, s, c, d); return p.onDestroy(() => { var t; (t = h).parentNode.removeChild(t) }), p } _notifyFaultyScrubber() { this._warningIssued || (console.warn("@angular/animations: please load the web-animations.js polyfill to allow programmatic access...\n", "  visit http://bit.ly/IWukam to learn more about using the web-animation-js polyfill."), this._warningIssued = !0) } } class hh { constructor(t, e, n, r) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : tu(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class dh { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(ph().toString()), this._cssKeyframesDriver = new uh } validateStyleProperty(t) { return Pc(t) } matchesElement(t, e) { return Oc(t, e) } containsElement(t, e) { return Ac(t, e) } query(t, e, n) { return Mc(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, r, s, i = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, r, s, i); const a = { duration: n, delay: r, fill: 0 == r ? "both" : "forwards" }; s && (a.easing = s); const l = {}, c = i.filter(t => t instanceof hh); Yc(n, r) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const u = Yu(t, e = Xc(t, e = e.map(t => Uc(t, !1)), l)); return new hh(t, e, a, u) } } function ph() { return "undefined" != typeof window && void 0 !== window.document && Element.prototype.animate || {} } let fh = (() => { class t extends tc { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: ne.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? sc(t) : t; return yh(this._renderer, null, e, "register", [n]), new mh(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(zi), Wt(Wa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); class mh extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new gh(this._id, t, e || {}, this._renderer) } } class gh { constructor(t, e, n, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return yh(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset") } setPosition(t) { this._command("setPosition", t) } getPosition() { return 0 } } function yh(t, e, n, r, s) { return t.setProperty(e, `@@${n}:${r}`, s) } let _h = (() => { class t { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new vh("", n, this.engine), this._rendererCache.set(n, t)), t } const r = e.id, s = e.id + "-" + this._currentId; this._currentId++, this.engine.register(s, t); const i = e => { Array.isArray(e) ? e.forEach(i) : this.engine.registerTrigger(r, s, t, e.name, e) }; return e.data.animation.forEach(i), new wh(this, s, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(Wt(zi), Wt(Zu), Wt(pa)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); class vh { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, !0) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, r) { this.delegate.setAttribute(t, e, n, r) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, r) { this.delegate.setStyle(t, e, n, r) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { "@" == e.charAt(0) && "@.disabled" == e ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class wh extends vh { constructor(t, e, n, r) { super(e, n, r), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { "@" == e.charAt(0) ? "." == e.charAt(1) && "@.disabled" == e ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if ("@" == e.charAt(0)) { const r = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let s = e.substr(1), i = ""; return "@" != s.charAt(0) && ([s, i] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, r, s, i, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let bh = (() => { class t extends Zu { constructor(t, e, n) { super(t.body, e, n) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Wa), Wt(Nc), Wt(Su)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const Ch = [{ provide: Nc, useFactory: function () { return "function" == typeof ph() ? new dh : new uh } }, { provide: new Dt("AnimationModuleType"), useValue: "BrowserAnimations" }, { provide: tc, useClass: fh }, { provide: Su, useFactory: function () { return new xu } }, { provide: Zu, useClass: bh }, { provide: zi, useFactory: function (t, e, n) { return new _h(t, e, n) }, deps: [Hl, Zu, pa] }]; let Sh = (() => { class t { } return t.\u0275mod = ue({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: Ch, imports: [Jl] }), t })(); const xh = new _(t => t.complete()); function Eh(t) { return t ? function (t) { return new _(e => t.schedule(() => e.complete())) }(t) : xh } function kh(t) { return new _(e => { let n; try { n = t() } catch (r) { return void e.error(r) } return (n ? U(n) : Eh()).subscribe(e) }) } function Th(t, e) { return new _(e ? n => e.schedule(Ph, 0, { error: t, subscriber: n }) : e => e.error(t)) } function Ph({ error: t, subscriber: e }) { e.error(t) } function Oh(t, e, n, s) { return r(n) && (s = n, n = void 0), s ? Oh(t, e, n).pipe(j(t => l(t) ? s(...t) : s(t))) : new _(r => { !function t(e, n, r, s, i) { let o; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(e)) { const t = e; e.addEventListener(n, r, i), o = () => t.removeEventListener(n, r, i) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(e)) { const t = e; e.on(n, r), o = () => t.off(n, r) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(e)) { const t = e; e.addListener(n, r), o = () => t.removeListener(n, r) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let o = 0, a = e.length; o < a; o++)t(e[o], n, r, s, i) } s.add(o) }(t, e, (function (t) { r.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }), r, n) }) } function Ah(...t) { let e = t[t.length - 1]; return E(e) ? (t.pop(), L(t, e)) : $(t) } function Mh() { return V(1) } function Ih(...t) { return Mh()(Ah(...t)) } function Rh() { } const Nh = new _(Rh); function jh(t, e) { return function (n) { return n.lift(new Dh(t, e)) } } class Dh { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new Fh(t, this.predicate, this.thisArg)) } } class Fh extends f { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } function Lh(t, e) { return "function" == typeof e ? n => n.pipe(Lh((n, r) => U(t(n, r)).pipe(j((t, s) => e(n, t, r, s))))) : e => e.lift(new Uh(t)) } class Uh { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new zh(t, this.project)) } } class zh extends N { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (r) { return void this.destination.error(r) } this._innerSub(e, t, n) } _innerSub(t, e, n) { const r = this.innerSubscription; r && r.unsubscribe(); const s = new k(this, e, n), i = this.destination; i.add(s), this.innerSubscription = R(this, t, void 0, void 0, s), this.innerSubscription !== s && i.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = null } notifyComplete(t) { this.destination.remove(t), this.innerSubscription = null, this.isStopped && super._complete() } notifyNext(t, e, n, r, s) { this.destination.next(e) } } const Hh = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })(); function Bh(t) { return e => 0 === t ? Eh() : e.lift(new Vh(t)) } class Vh { constructor(t) { if (this.total = t, this.total < 0) throw new Hh } call(t, e) { return e.subscribe(new $h(t, this.total)) } } class $h extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function qh(t, e, n) { return function (r) { return r.lift(new Wh(t, e, n)) } } class Wh { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new Qh(t, this.nextOrObserver, this.error, this.complete)) } } class Qh extends f { constructor(t, e, n, s) { super(t), this._tapNext = Rh, this._tapError = Rh, this._tapComplete = Rh, this._tapError = n || Rh, this._tapComplete = s || Rh, r(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || Rh, this._tapError = e.error || Rh, this._tapComplete = e.complete || Rh) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } class Gh extends h { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class Kh extends Gh { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n = !1, r = void 0; try { this.work(t) } catch (s) { n = !0, r = !!s && s || new Error(s) } if (n) return this.unsubscribe(), r } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, r = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && n.splice(r, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let Zh = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class Yh extends Zh { constructor(t, e = Zh.now) { super(t, () => Yh.delegate && Yh.delegate !== this ? Yh.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return Yh.delegate && Yh.delegate !== this ? Yh.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } const Xh = new Yh(Kh); let Jh = (() => { class t { constructor(t, e, n) { this.kind = t, this.value = e, this.error = n, this.hasValue = "N" === t } observe(t) { switch (this.kind) { case "N": return t.next && t.next(this.value); case "E": return t.error && t.error(this.error); case "C": return t.complete && t.complete() } } do(t, e, n) { switch (this.kind) { case "N": return t && t(this.value); case "E": return e && e(this.error); case "C": return n && n() } } accept(t, e, n) { return t && "function" == typeof t.next ? this.observe(t) : this.do(t, e, n) } toObservable() { switch (this.kind) { case "N": return Ah(this.value); case "E": return Th(this.error); case "C": return Eh() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new t("N", e) : t.undefinedValueNotification } static createError(e) { return new t("E", void 0, e) } static createComplete() { return t.completeNotification } } return t.completeNotification = new t("C"), t.undefinedValueNotification = new t("N", void 0), t })(); class td { constructor(t, e) { this.delay = t, this.scheduler = e } call(t, e) { return e.subscribe(new ed(t, this.delay, this.scheduler)) } } class ed extends f { constructor(t, e, n) { super(t), this.delay = e, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(t) { const e = t.source, n = e.queue, r = t.scheduler, s = t.destination; for (; n.length > 0 && n[0].time - r.now() <= 0;)n.shift().notification.observe(s); if (n.length > 0) { const e = Math.max(0, n[0].time - r.now()); this.schedule(t, e) } else this.unsubscribe(), e.active = !1 } _schedule(t) { this.active = !0, this.destination.add(t.schedule(ed.dispatch, this.delay, { source: this, destination: this.destination, scheduler: t })) } scheduleNotification(t) { if (!0 === this.errored) return; const e = this.scheduler, n = new nd(e.now() + this.delay, t); this.queue.push(n), !1 === this.active && this._schedule(e) } _next(t) { this.scheduleNotification(Jh.createNext(t)) } _error(t) { this.errored = !0, this.queue = [], this.destination.error(t), this.unsubscribe() } _complete() { this.scheduleNotification(Jh.createComplete()), this.unsubscribe() } } class nd { constructor(t, e) { this.time = t, this.notification = e } } const rd = "Service workers are disabled or not supported by this browser"; class sd { constructor(t) { if (this.serviceWorker = t, t) { const e = Oh(t, "controllerchange").pipe(j(() => t.controller)), n = Ih(kh(() => Ah(t.controller)), e); this.worker = n.pipe(jh(t => !!t)), this.registration = this.worker.pipe(Lh(() => t.getRegistration())); const r = Oh(t, "message").pipe(j(t => t.data)).pipe(jh(t => t && t.type)).pipe(X(new S)); r.connect(), this.events = r } else this.worker = this.events = this.registration = kh(() => Th(new Error("Service workers are disabled or not supported by this browser"))) } postMessage(t, e) { return this.worker.pipe(Bh(1), qh(n => { n.postMessage(Object.assign({ action: t }, e)) })).toPromise().then(() => { }) } postMessageWithStatus(t, e, n) { const r = this.waitForStatus(n), s = this.postMessage(t, e); return Promise.all([r, s]).then(() => { }) } generateNonce() { return Math.round(1e7 * Math.random()) } eventsOfType(t) { return this.events.pipe(jh(e => e.type === t)) } nextEventOfType(t) { return this.eventsOfType(t).pipe(Bh(1)) } waitForStatus(t) { return this.eventsOfType("STATUS").pipe(jh(e => e.nonce === t), Bh(1), j(t => { if (!t.status) throw new Error(t.error) })).toPromise() } get isEnabled() { return !!this.serviceWorker } } let id = (() => { class t { constructor(t) { if (this.sw = t, this.subscriptionChanges = new S, !t.isEnabled) return this.messages = Nh, this.notificationClicks = Nh, void (this.subscription = Nh); this.messages = this.sw.eventsOfType("PUSH").pipe(j(t => t.data)), this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe(j(t => t.data)), this.pushManager = this.sw.registration.pipe(j(t => t.pushManager)); const e = this.pushManager.pipe(Lh(t => t.getSubscription())); this.subscription = q(e, this.subscriptionChanges) } get isEnabled() { return this.sw.isEnabled } requestSubscription(t) { if (!this.sw.isEnabled) return Promise.reject(new Error(rd)); const e = { userVisibleOnly: !0 }; let n = this.decodeBase64(t.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+")), r = new Uint8Array(new ArrayBuffer(n.length)); for (let s = 0; s < n.length; s++)r[s] = n.charCodeAt(s); return e.applicationServerKey = r, this.pushManager.pipe(Lh(t => t.subscribe(e)), Bh(1)).toPromise().then(t => (this.subscriptionChanges.next(t), t)) } unsubscribe() { return this.sw.isEnabled ? this.subscription.pipe(Bh(1), Lh(t => { if (null === t) throw new Error("Not subscribed to push notifications."); return t.unsubscribe().then(t => { if (!t) throw new Error("Unsubscribe failed!"); this.subscriptionChanges.next(null) }) })).toPromise() : Promise.reject(new Error(rd)) } decodeBase64(t) { return atob(t) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(sd)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), od = (() => { class t { constructor(t) { if (this.sw = t, !t.isEnabled) return this.available = Nh, void (this.activated = Nh); this.available = this.sw.eventsOfType("UPDATE_AVAILABLE"), this.activated = this.sw.eventsOfType("UPDATE_ACTIVATED") } get isEnabled() { return this.sw.isEnabled } checkForUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(rd)); const t = this.sw.generateNonce(); return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES", { statusNonce: t }, t) } activateUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(rd)); const t = this.sw.generateNonce(); return this.sw.postMessageWithStatus("ACTIVATE_UPDATE", { statusNonce: t }, t) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(sd)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); class ad { } const ld = new Dt("NGSW_REGISTER_SCRIPT"); function cd(t, e, n, r) { return () => { if (!Cl(r) || !("serviceWorker" in navigator) || !1 === n.enabled) return; let s; if (navigator.serviceWorker.addEventListener("controllerchange", () => { null !== navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({ action: "INITIALIZE" }) }), "function" == typeof n.registrationStrategy) s = n.registrationStrategy(); else { const [e, ...r] = (n.registrationStrategy || "registerWhenStable:30000").split(":"); switch (e) { case "registerImmediately": s = Ah(null); break; case "registerWithDelay": s = ud(+r[0] || 0); break; case "registerWhenStable": s = r[0] ? q(hd(t), ud(+r[0])) : hd(t); break; default: throw new Error("Unknown ServiceWorker registration strategy: " + n.registrationStrategy) } } t.get(pa).runOutsideAngular(() => s.pipe(Bh(1)).subscribe(() => navigator.serviceWorker.register(e, { scope: n.scope }).catch(t => console.error("Service worker registration failed with:", t)))) } } function ud(t) { return Ah(null).pipe(function (t, e = Xh) { var n; const r = (n = t) instanceof Date && !isNaN(+n) ? +t - e.now() : Math.abs(t); return t => t.lift(new td(r, e)) }(t)) } function hd(t) { return t.get(Ia).isStable.pipe(jh(t => t)) } function dd(t, e) { return new sd(Cl(e) && !1 !== t.enabled ? navigator.serviceWorker : void 0) } let pd = (() => { class t { static register(e, n = {}) { return { ngModule: t, providers: [{ provide: ld, useValue: e }, { provide: ad, useValue: n }, { provide: sd, useFactory: dd, deps: [ad, Xo] }, { provide: Wo, useFactory: cd, deps: [ai, ld, ad, Xo], multi: !0 }] } } } return t.\u0275mod = ue({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [id, od] }), t })(); class fd extends S { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new w; return this._value } next(t) { super.next(this._value = t) } } const md = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(), gd = {}; class yd { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new _d(t, this.resultSelector)) } } class _d extends N { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(gd), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++) { const e = t[n]; this.add(R(this, e, e, n)) } } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n, r, s) { const i = this.values, o = this.toRespond ? i[n] === gd ? --this.toRespond : this.toRespond : 0; i[n] = e, 0 === o && (this.resultSelector ? this._tryResultSelector(i) : this.destination.next(i.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } function vd(t) { return function (e) { return 0 === t ? Eh() : e.lift(new wd(t)) } } class wd { constructor(t) { if (this.total = t, this.total < 0) throw new Hh } call(t, e) { return e.subscribe(new bd(t, this.total)) } } class bd extends f { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, r = this.count++; e.length < n ? e.push(t) : e[r % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let s = 0; s < n; s++) { const s = e++ % n; t.next(r[s]) } } t.complete() } } function Cd(t = Ed) { return e => e.lift(new Sd(t)) } class Sd { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new xd(t, this.errorFactory)) } } class xd extends f { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function Ed() { return new md } function kd(t = null) { return e => e.lift(new Td(t)) } class Td { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new Pd(t, this.defaultValue)) } } class Pd extends f { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function Od(t) { return function (e) { const n = new Ad(t), r = e.lift(n); return n.caught = r } } class Ad { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new Md(t, this.selector, this.caught)) } } class Md extends N { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const r = new k(this, void 0, void 0); this.add(r); const s = R(this, n, void 0, void 0, r); s !== r && this.add(s) } } } function Id(t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? jh((e, n) => t(e, n, r)) : y, Bh(1), n ? kd(e) : Cd(() => new md)) } class Rd { constructor(t, e, n) { this.predicate = t, this.thisArg = e, this.source = n } call(t, e) { return e.subscribe(new Nd(t, this.predicate, this.thisArg, this.source)) } } class Nd extends f { constructor(t, e, n, r) { super(t), this.predicate = e, this.thisArg = n, this.source = r, this.index = 0, this.thisArg = n || this } notifyComplete(t) { this.destination.next(t), this.destination.complete() } _next(t) { let e = !1; try { e = this.predicate.call(this.thisArg, t, this.index++, this.source) } catch (n) { return void this.destination.error(n) } e || this.notifyComplete(!1) } _complete() { this.notifyComplete(!0) } } class jd { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new Dd(t, this.accumulator, this.seed, this.hasSeed)) } } class Dd extends f { constructor(t, e, n, r) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } function Fd(t, e) { return z(t, e, 1) } class Ld { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new Ud(t, this.callback)) } } class Ud extends f { constructor(t, e) { super(t), this.add(new h(e)) } } class zd { constructor(t, e) { this.id = t, this.url = e } } class Hd extends zd { constructor(t, e, n = "imperative", r = null) { super(t, e), this.navigationTrigger = n, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Bd extends zd { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Vd extends zd { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class $d extends zd { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class qd extends zd { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Wd extends zd { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Qd extends zd { constructor(t, e, n, r, s) { super(t, e), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class Gd extends zd { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Kd extends zd { constructor(t, e, n, r) { super(t, e), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Zd { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Yd { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class Xd { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Jd { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class tp { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ep { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class np { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class rp { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function sp(t) { return new rp(t) } function ip(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function op(t, e, n) { const r = n.path.split("/"); if (r.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || r.length < t.length)) return null; const s = {}; for (let i = 0; i < r.length; i++) { const e = r[i], n = t[i]; if (e.startsWith(":")) s[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, r.length), posParams: s } } function ap(t, e) { const n = Object.keys(t), r = Object.keys(e); if (!n || !r || n.length != r.length) return !1; let s; for (let i = 0; i < n.length; i++)if (s = n[i], !lp(t[s], e[s])) return !1; return !0 } function lp(t, e) { return Array.isArray(t) && Array.isArray(e) ? t.length == e.length && t.every(t => e.indexOf(t) > -1) : t === e } function cp(t) { return Array.prototype.concat.apply([], t) } function up(t) { return t.length > 0 ? t[t.length - 1] : null } function hp(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function dp(t) { return (e = t) && "function" == typeof e.subscribe ? t : Ei(t) ? U(Promise.resolve(t)) : Ah(t); var e } function pp(t, e, n) { return n ? function (t, e) { return ap(t, e) }(t.queryParams, e.queryParams) && function t(e, n) { if (!yp(e.segments, n.segments)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const r in n.children) { if (!e.children[r]) return !1; if (!t(e.children[r], n.children[r])) return !1 } return !0 }(t.root, e.root) : function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => lp(t[n], e[n])) }(t.queryParams, e.queryParams) && function t(e, n) { return function e(n, r, s) { if (n.segments.length > s.length) return !!yp(n.segments.slice(0, s.length), s) && !r.hasChildren(); if (n.segments.length === s.length) { if (!yp(n.segments, s)) return !1; for (const e in r.children) { if (!n.children[e]) return !1; if (!t(n.children[e], r.children[e])) return !1 } return !0 } { const t = s.slice(0, n.segments.length), i = s.slice(n.segments.length); return !!yp(n.segments, t) && !!n.children.primary && e(n.children.primary, r, i) } }(e, n, n.segments) }(t.root, e.root) } class fp { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = sp(this.queryParams)), this._queryParamMap } toString() { return bp.serialize(this) } } class mp { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, hp(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Cp(this) } } class gp { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = sp(this.parameters)), this._parameterMap } toString() { return Pp(this) } } function yp(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } function _p(t, e) { let n = []; return hp(t.children, (t, r) => { "primary" === r && (n = n.concat(e(t, r))) }), hp(t.children, (t, r) => { "primary" !== r && (n = n.concat(e(t, r))) }), n } class vp { } class wp { parse(t) { const e = new Rp(t); return new fp(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { return `${"/" + function t(e, n) { if (!e.hasChildren()) return Cp(e); if (n) { const n = e.children.primary ? t(e.children.primary, !1) : "", r = []; return hp(e.children, (e, n) => { "primary" !== n && r.push(`${n}:${t(e, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = _p(e, (n, r) => "primary" === r ? [t(e.children.primary, !1)] : [`${r}:${t(n, !1)}`]); return `${Cp(e)}/(${n.join("//")})` } }(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${xp(e)}=${xp(t)}`).join("&") : `${xp(e)}=${xp(n)}` }); return e.length ? "?" + e.join("&") : "" }(t.queryParams)}${"string" == typeof t.fragment ? "#" + encodeURI(t.fragment) : ""}` } } const bp = new wp; function Cp(t) { return t.segments.map(t => Pp(t)).join("/") } function Sp(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function xp(t) { return Sp(t).replace(/%3B/gi, ";") } function Ep(t) { return Sp(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function kp(t) { return decodeURIComponent(t) } function Tp(t) { return kp(t.replace(/\+/g, "%20")) } function Pp(t) { return `${Ep(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${Ep(t)}=${Ep(e[t])}`).join("")}`; var e } const Op = /^[^\/()?;=#]+/; function Ap(t) { const e = t.match(Op); return e ? e[0] : "" } const Mp = /^[^=?&#]+/, Ip = /^[^?&#]+/; class Rp { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new mp([], {}) : new mp([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new mp(t, e)), n } parseSegment() { const t = Ap(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new gp(kp(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = Ap(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = Ap(this.remaining); t && (n = t, this.capture(n)) } t[kp(e)] = kp(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(Mp); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(Ip); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const r = Tp(e), s = Tp(n); if (t.hasOwnProperty(r)) { let e = t[r]; Array.isArray(e) || (e = [e], t[r] = e), e.push(s) } else t[r] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = Ap(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let s = void 0; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = "primary"); const i = this.parseChildren(); e[s] = 1 === Object.keys(i).length ? i.primary : new mp([], i), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class Np { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = jp(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = jp(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = Dp(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return Dp(t, this._root).map(t => t.value) } } function jp(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = jp(t, n); if (e) return e } return null } function Dp(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const r = Dp(t, n); if (r.length) return r.unshift(e), r } return [] } class Fp { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function Lp(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class Up extends Np { constructor(t, e) { super(t), this.snapshot = e, qp(this, t) } toString() { return this.snapshot.toString() } } function zp(t, e) { const n = function (t, e) { const n = new Vp([], {}, {}, "", {}, "primary", e, null, t.root, -1, {}); return new $p("", new Fp(n, [])) }(t, e), r = new fd([new gp("", {})]), s = new fd({}), i = new fd({}), o = new fd({}), a = new fd(""), l = new Hp(r, s, o, a, i, "primary", e, n.root); return l.snapshot = n.root, new Up(new Fp(l, []), n) } class Hp { constructor(t, e, n, r, s, i, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(j(t => sp(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(j(t => sp(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function Bp(t, e = "emptyOnly") { const n = t.pathFromRoot; let r = 0; if ("always" !== e) for (r = n.length - 1; r >= 1;) { const t = n[r], e = n[r - 1]; if (t.routeConfig && "" === t.routeConfig.path) r--; else { if (e.component) break; r-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class Vp { constructor(t, e, n, r, s, i, o, a, l, c, u) { this.url = t, this.params = e, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = u } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = sp(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = sp(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class $p extends Np { constructor(t, e) { super(e), this.url = t, qp(this, e) } toString() { return Wp(this._root) } } function qp(t, e) { e.value._routerState = t, e.children.forEach(e => qp(t, e)) } function Wp(t) { const e = t.children.length > 0 ? ` { ${t.children.map(Wp).join(", ")} } ` : ""; return `${t.value}${e}` } function Qp(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, ap(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), ap(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!ap(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), ap(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function Gp(t, e) { var n, r; return ap(t.params, e.params) && yp(n = t.url, r = e.url) && n.every((t, e) => ap(t.parameters, r[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || Gp(t.parent, e.parent)) } function Kp(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Zp(t, e, n, r, s) { let i = {}; return r && hp(r, (t, e) => { i[e] = Array.isArray(t) ? t.map(t => "" + t) : "" + t }), new fp(n.root === t ? e : function t(e, n, r) { const s = {}; return hp(e.children, (e, i) => { s[i] = e === n ? r : t(e, n, r) }), new mp(e.segments, s) }(n.root, t, e), i, s) } class Yp { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && Kp(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(t => "object" == typeof t && null != t && t.outlets); if (r && r !== up(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Xp { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function Jp(t) { return "object" == typeof t && null != t && t.outlets ? t.outlets.primary : "" + t } function tf(t, e, n) { if (t || (t = new mp([], {})), 0 === t.segments.length && t.hasChildren()) return ef(t, e, n); const r = function (t, e, n) { let r = 0, s = e; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (r >= n.length) return i; const e = t.segments[s], o = Jp(n[r]), a = r < n.length - 1 ? n[r + 1] : null; if (s > 0 && void 0 === o) break; if (o && a && "object" == typeof a && void 0 === a.outlets) { if (!of(o, a, e)) return i; r += 2 } else { if (!of(o, {}, e)) return i; r++ } s++ } return { match: !0, pathIndex: s, commandIndex: r } }(t, e, n), s = n.slice(r.commandIndex); if (r.match && r.pathIndex < t.segments.length) { const e = new mp(t.segments.slice(0, r.pathIndex), {}); return e.children.primary = new mp(t.segments.slice(r.pathIndex), t.children), ef(e, 0, s) } return r.match && 0 === s.length ? new mp(t.segments, {}) : r.match && !t.hasChildren() ? nf(t, e, n) : r.match ? ef(t, 0, s) : nf(t, e, n) } function ef(t, e, n) { if (0 === n.length) return new mp(t.segments, {}); { const r = function (t) { return "object" == typeof t[0] && null !== t[0] && t[0].outlets ? t[0].outlets : { primary: t } }(n), s = {}; return hp(r, (n, r) => { null !== n && (s[r] = tf(t.children[r], e, n)) }), hp(t.children, (t, e) => { void 0 === r[e] && (s[e] = t) }), new mp(t.segments, s) } } function nf(t, e, n) { const r = t.segments.slice(0, e); let s = 0; for (; s < n.length;) { if ("object" == typeof n[s] && null !== n[s] && void 0 !== n[s].outlets) { const t = rf(n[s].outlets); return new mp(r, t) } if (0 === s && Kp(n[0])) { r.push(new gp(t.segments[e].path, n[0])), s++; continue } const i = Jp(n[s]), o = s < n.length - 1 ? n[s + 1] : null; i && o && Kp(o) ? (r.push(new gp(i, sf(o))), s += 2) : (r.push(new gp(i, {})), s++) } return new mp(r, {}) } function rf(t) { const e = {}; return hp(t, (t, n) => { null !== t && (e[n] = nf(new mp([], {}), 0, t)) }), e } function sf(t) { const e = {}; return hp(t, (t, n) => e[n] = "" + t), e } function of(t, e, n) { return t == n.path && ap(e, n.parameters) } class af { constructor(t, e, n, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = r } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), Qp(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const r = Lp(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, r[e], n), delete r[e] }), hp(r, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (r === s) if (r.component) { const s = n.getContext(r.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, n); else s && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: r }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet); if (n) { const r = Lp(t), s = t.value.component ? n.children : e; hp(r, (t, e) => this.deactivateRouteAndItsChildren(t, s)), n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated()) } } activateChildRoutes(t, e, n) { const r = Lp(e); t.children.forEach(t => { this.activateRoutes(t, r[t.value.outlet], n), this.forwardEvent(new ep(t.value.snapshot)) }), t.children.length && this.forwardEvent(new Jd(t.value.snapshot)) } activateRoutes(t, e, n) { const r = t.value, s = e ? e.value : null; if (Qp(r), r === s) if (r.component) { const s = n.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, n); else if (r.component) { const e = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const t = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), lf(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(r.snapshot), s = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = r, e.resolver = s, e.outlet && e.outlet.activateWith(r, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function lf(t) { Qp(t.value), t.children.forEach(lf) } class cf { constructor(t, e) { this.routes = t, this.module = e } } function uf(t) { return "function" == typeof t } function hf(t) { return t instanceof fp } class df { constructor(t) { this.segmentGroup = t || null } } class pf { constructor(t) { this.urlTree = t } } function ff(t) { return new _(e => e.error(new df(t))) } function mf(t) { return new _(e => e.error(new pf(t))) } function gf(t) { return new _(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class yf { constructor(t, e, n, r, s) { this.configLoader = e, this.urlSerializer = n, this.urlTree = r, this.config = s, this.allowRedirects = !0, this.ngModule = t.get(Zt) } apply() { return this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, "primary").pipe(j(t => this.createUrlTree(t, this.urlTree.queryParams, this.urlTree.fragment))).pipe(Od(t => { if (t instanceof pf) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof df) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, "primary").pipe(j(e => this.createUrlTree(e, t.queryParams, t.fragment))).pipe(Od(t => { if (t instanceof df) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const r = t.segments.length > 0 ? new mp([], { primary: t }) : t; return new fp(r, e, n) } expandSegmentGroup(t, e, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(j(t => new mp([], t))) : this.expandSegment(t, n, e, n.segments, r, !0) } expandChildren(t, e, n) { return function (t, e) { if (0 === Object.keys(t).length) return Ah({}); const n = [], r = [], s = {}; return hp(t, (t, i) => { const o = e(i, t).pipe(j(t => s[i] = t)); "primary" === i ? n.push(o) : r.push(o) }), Ah.apply(null, n.concat(r)).pipe(Mh(), function (t, e) { const n = arguments.length >= 2; return r => r.pipe(t ? jh((e, n) => t(e, n, r)) : y, vd(1), n ? kd(e) : Cd(() => new md)) }(), j(() => s)) }(n.children, (n, r) => this.expandSegmentGroup(t, e, r, n)) } expandSegment(t, e, n, r, s, i) { return Ah(...n).pipe(j(o => this.expandSegmentAgainstRoute(t, e, n, o, r, s, i).pipe(Od(t => { if (t instanceof df) return Ah(null); throw t }))), Mh(), Id(t => !!t), Od((t, n) => { if (t instanceof md || "EmptyError" === t.name) { if (this.noLeftoversInUrl(e, r, s)) return Ah(new mp([], {})); throw new df(e) } throw t })) } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } expandSegmentAgainstRoute(t, e, n, r, s, i, o) { return bf(r) !== i ? ff(e) : void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, s) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) : ff(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, r) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? mf(s) : this.lineralizeSegments(n, s).pipe(z(n => { const s = new mp(n, {}); return this.expandSegment(t, s, e, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, r, s, i) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = _f(e, r, s); if (!o) return ff(e); const u = this.applyRedirectCommands(a, r.redirectTo, c); return r.redirectTo.startsWith("/") ? mf(u) : this.lineralizeSegments(r, u).pipe(z(r => this.expandSegment(t, e, n, r.concat(s.slice(l)), i, !1))) } matchSegmentAgainstRoute(t, e, n, r) { if ("**" === n.path) return n.loadChildren ? this.configLoader.load(t.injector, n).pipe(j(t => (n._loadedConfig = t, new mp(r, {})))) : Ah(new mp(r, {})); const { matched: s, consumedSegments: i, lastChild: o } = _f(e, n, r); if (!s) return ff(e); const a = r.slice(o); return this.getChildConfig(t, n, r).pipe(z(t => { const n = t.module, r = t.routes, { segmentGroup: s, slicedSegments: o } = function (t, e, n, r) { return n.length > 0 && function (t, e, n) { return n.some(n => wf(t, e, n) && "primary" !== bf(n)) }(t, n, r) ? { segmentGroup: vf(new mp(e, function (t, e) { const n = {}; n.primary = e; for (const r of t) "" === r.path && "primary" !== bf(r) && (n[bf(r)] = new mp([], {})); return n }(r, new mp(n, t.children)))), slicedSegments: [] } : 0 === n.length && function (t, e, n) { return n.some(n => wf(t, e, n)) }(t, n, r) ? { segmentGroup: vf(new mp(t.segments, function (t, e, n, r) { const s = {}; for (const i of n) wf(t, e, i) && !r[bf(i)] && (s[bf(i)] = new mp([], {})); return Object.assign(Object.assign({}, r), s) }(t, n, r, t.children))), slicedSegments: n } : { segmentGroup: t, slicedSegments: n } }(e, i, a, r); return 0 === o.length && s.hasChildren() ? this.expandChildren(n, r, s).pipe(j(t => new mp(i, t))) : 0 === r.length && 0 === o.length ? Ah(new mp(i, {})) : this.expandSegment(n, s, r, o, "primary", !0).pipe(j(t => new mp(i.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? Ah(new cf(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? Ah(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, n).pipe(z(n => n ? this.configLoader.load(t.injector, e).pipe(j(t => (e._loadedConfig = t, t))) : function (t) { return new _(e => e.error(ip(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : Ah(new cf([], t)) } runCanLoadGuards(t, e, n) { const r = e.canLoad; return r && 0 !== r.length ? U(r).pipe(j(r => { const s = t.get(r); let i; if (function (t) { return t && uf(t.canLoad) }(s)) i = s.canLoad(e, n); else { if (!uf(s)) throw new Error("Invalid CanLoad guard"); i = s(e, n) } return dp(i) })).pipe(Mh(), qh(t => { if (!hf(t)) return; const e = ip(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), (s = t => !0 === t, t => t.lift(new Rd(s, void 0, t)))) : Ah(!0); var s } lineralizeSegments(t, e) { let n = [], r = e.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return Ah(n); if (r.numberOfChildren > 1 || !r.children.primary) return gf(t.redirectTo); r = r.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, r) { const s = this.createSegmentGroup(t, e.root, n, r); return new fp(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return hp(t, (t, r) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1); n[r] = e[s] } else n[r] = t }), n } createSegmentGroup(t, e, n, r) { const s = this.createSegments(t, e.segments, n, r); let i = {}; return hp(e.children, (e, s) => { i[s] = this.createSegmentGroup(t, e, n, r) }), new mp(s, i) } createSegments(t, e, n, r) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, r) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const r = n[e.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return r } findOrReturn(t, e) { let n = 0; for (const r of e) { if (r.path === t.path) return e.splice(n), r; n++ } return t } } function _f(t, e, n) { if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } : { matched: !0, consumedSegments: [], lastChild: 0, positionalParamSegments: {} }; const r = (e.matcher || op)(n, t, e); return r ? { matched: !0, consumedSegments: r.consumed, lastChild: r.consumed.length, positionalParamSegments: r.posParams } : { matched: !1, consumedSegments: [], lastChild: 0, positionalParamSegments: {} } } function vf(t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new mp(t.segments.concat(e.segments), e.children) } return t } function wf(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 !== n.redirectTo } function bf(t) { return t.outlet || "primary" } class Cf { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Sf { constructor(t, e) { this.component = t, this.route = e } } function xf(t, e, n) { const r = t._root; return function t(e, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = Lp(n); return e.children.forEach(e => { !function (e, n, r, s, i = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = e.value, a = n ? n.value : null, l = r ? r.getContext(e.value.outlet) : null; if (a && o.routeConfig === a.routeConfig) { const c = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !yp(t.url, e.url); case "pathParamsOrQueryParamsChange": return !yp(t.url, e.url) || !ap(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !Gp(t, e) || !ap(t.queryParams, e.queryParams); case "paramsChange": default: return !Gp(t, e) } }(a, o, o.routeConfig.runGuardsAndResolvers); c ? i.canActivateChecks.push(new Cf(s)) : (o.data = a.data, o._resolvedData = a._resolvedData), t(e, n, o.component ? l ? l.children : null : r, s, i), c && i.canDeactivateChecks.push(new Sf(l && l.outlet && l.outlet.component || null, a)) } else a && kf(n, l, i), i.canActivateChecks.push(new Cf(s)), t(e, null, o.component ? l ? l.children : null : r, s, i) }(e, o[e.value.outlet], r, s.concat([e.value]), i), delete o[e.value.outlet] }), hp(o, (t, e) => kf(t, r.getContext(e), i)), i }(r, e ? e._root : null, n, [r.value]) } function Ef(t, e, n) { const r = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (r ? r.module.injector : n).get(t) } function kf(t, e, n) { const r = Lp(t), s = t.value; hp(r, (t, r) => { kf(t, s.component ? e ? e.children.getContext(r) : null : e, n) }), n.canDeactivateChecks.push(new Sf(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) } const Tf = Symbol("INITIAL_VALUE"); function Pf() { return Lh(t => function (...t) { let e = null, n = null; return E(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), $(t, n).lift(new yd(e)) }(...t.map(t => t.pipe(Bh(1), function (...t) { const e = t[t.length - 1]; return E(e) ? (t.pop(), n => Ih(t, n, e)) : e => Ih(t, e) }(Tf)))).pipe(function (t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new jd(t, e, n)) } }((t, e) => { let n = !1; return e.reduce((t, r, s) => { if (t !== Tf) return t; if (r === Tf && (n = !0), !n) { if (!1 === r) return r; if (s === e.length - 1 || hf(r)) return r } return t }, t) }, Tf), jh(t => t !== Tf), j(t => hf(t) ? t : !0 === t), Bh(1))) } function Of(t, e) { return null !== t && e && e(new tp(t)), Ah(!0) } function Af(t, e) { return null !== t && e && e(new Xd(t)), Ah(!0) } function Mf(t, e, n) { const r = e.routeConfig ? e.routeConfig.canActivate : null; return r && 0 !== r.length ? Ah(r.map(r => kh(() => { const s = Ef(r, e, n); let i; if (function (t) { return t && uf(t.canActivate) }(s)) i = dp(s.canActivate(e, t)); else { if (!uf(s)) throw new Error("Invalid CanActivate guard"); i = dp(s(e, t)) } return i.pipe(Id()) }))).pipe(Pf()) : Ah(!0) } function If(t, e, n) { const r = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => kh(() => Ah(e.guards.map(s => { const i = Ef(s, e.node, n); let o; if (function (t) { return t && uf(t.canActivateChild) }(i)) o = dp(i.canActivateChild(r, t)); else { if (!uf(i)) throw new Error("Invalid CanActivateChild guard"); o = dp(i(r, t)) } return o.pipe(Id()) })).pipe(Pf()))); return Ah(s).pipe(Pf()) } class Rf { } class Nf { constructor(t, e, n, r, s, i) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = i } recognize() { try { const t = Ff(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, "primary"), n = new Vp([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, "primary", this.rootComponentType, null, this.urlTree.root, -1, {}), r = new Fp(n, e), s = new $p(this.url, r); return this.inheritParamsAndData(s._root), Ah(s) } catch (t) { return new _(e => e.error(t)) } } inheritParamsAndData(t) { const e = t.value, n = Bp(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = _p(e, (e, n) => this.processSegmentGroup(t, e, n)); return function (t) { const e = {}; t.forEach(t => { const n = e[t.value.outlet]; if (n) { const e = n.url.map(t => t.toString()).join("/"), r = t.value.url.map(t => t.toString()).join("/"); throw new Error(`Two segments cannot have the same outlet name: '${e}' and '${r}'.`) } e[t.value.outlet] = t.value }) }(n), n.sort((t, e) => "primary" === t.value.outlet ? -1 : "primary" === e.value.outlet ? 1 : t.value.outlet.localeCompare(e.value.outlet)), n } processSegment(t, e, n, r) { for (const i of t) try { return this.processSegmentAgainstRoute(i, e, n, r) } catch (s) { if (!(s instanceof Rf)) throw s } if (this.noLeftoversInUrl(e, n, r)) return []; throw new Rf } noLeftoversInUrl(t, e, n) { return 0 === e.length && !t.children[n] } processSegmentAgainstRoute(t, e, n, r) { if (t.redirectTo) throw new Rf; if ((t.outlet || "primary") !== r) throw new Rf; let s, i = [], o = []; if ("**" === t.path) { const i = n.length > 0 ? up(n).parameters : {}; s = new Vp(n, i, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, zf(t), r, t.component, t, jf(e), Df(e) + n.length, Hf(t)) } else { const a = function (t, e, n) { if ("" === e.path) { if ("full" === e.pathMatch && (t.hasChildren() || n.length > 0)) throw new Rf; return { consumedSegments: [], lastChild: 0, parameters: {} } } const r = (e.matcher || op)(n, t, e); if (!r) throw new Rf; const s = {}; hp(r.posParams, (t, e) => { s[e] = t.path }); const i = r.consumed.length > 0 ? Object.assign(Object.assign({}, s), r.consumed[r.consumed.length - 1].parameters) : s; return { consumedSegments: r.consumed, lastChild: r.consumed.length, parameters: i } }(e, t, n); i = a.consumedSegments, o = n.slice(a.lastChild), s = new Vp(i, a.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, zf(t), r, t.component, t, jf(e), Df(e) + i.length, Hf(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = Ff(e, i, o, a, this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return [new Fp(s, t)] } if (0 === a.length && 0 === c.length) return [new Fp(s, [])]; const u = this.processSegment(a, l, c, "primary"); return [new Fp(s, u)] } } function jf(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function Df(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function Ff(t, e, n, r, s) { if (n.length > 0 && function (t, e, n) { return n.some(n => Lf(t, e, n) && "primary" !== Uf(n)) }(t, n, r)) { const s = new mp(e, function (t, e, n, r) { const s = {}; s.primary = r, r._sourceSegment = t, r._segmentIndexShift = e.length; for (const i of n) if ("" === i.path && "primary" !== Uf(i)) { const n = new mp([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, s[Uf(i)] = n } return s }(t, e, r, new mp(n, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => Lf(t, e, n)) }(t, n, r)) { const i = new mp(t.segments, function (t, e, n, r, s, i) { const o = {}; for (const a of r) if (Lf(t, n, a) && !s[Uf(a)]) { const n = new mp([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === i ? t.segments.length : e.length, o[Uf(a)] = n } return Object.assign(Object.assign({}, s), o) }(t, e, n, r, t.children, s)); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } const i = new mp(t.segments, t.children); return i._sourceSegment = t, i._segmentIndexShift = e.length, { segmentGroup: i, slicedSegments: n } } function Lf(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path && void 0 === n.redirectTo } function Uf(t) { return t.outlet || "primary" } function zf(t) { return t.data || {} } function Hf(t) { return t.resolve || {} } function Bf(t) { return function (e) { return e.pipe(Lh(e => { const n = t(e); return n ? U(n).pipe(j(() => e)) : U([e]) })) } } class Vf { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } } let $f = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && Si(0, "router-outlet") }, directives: function () { return [om] }, encapsulation: 2 }), t })(); function qf(t, e = "") { for (let n = 0; n < t.length; n++) { const r = t[n]; Wf(r, Qf(e, r)) } } function Wf(t, e) { if (!t) throw new Error(`\n      Invalid configuration of route '${e}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `); if (Array.isArray(t)) throw new Error(`Invalid configuration of route '${e}': Array cannot be specified`); if (!t.component && !t.children && !t.loadChildren && t.outlet && "primary" !== t.outlet) throw new Error(`Invalid configuration of route '${e}': a componentless route without children or loadChildren cannot have a named outlet set`); if (t.redirectTo && t.children) throw new Error(`Invalid configuration of route '${e}': redirectTo and children cannot be used together`); if (t.redirectTo && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': redirectTo and loadChildren cannot be used together`); if (t.children && t.loadChildren) throw new Error(`Invalid configuration of route '${e}': children and loadChildren cannot be used together`); if (t.redirectTo && t.component) throw new Error(`Invalid configuration of route '${e}': redirectTo and component cannot be used together`); if (t.path && t.matcher) throw new Error(`Invalid configuration of route '${e}': path and matcher cannot be used together`); if (void 0 === t.redirectTo && !t.component && !t.children && !t.loadChildren) throw new Error(`Invalid configuration of route '${e}'. One of the following must be provided: component, redirectTo, children or loadChildren`); if (void 0 === t.path && void 0 === t.matcher) throw new Error(`Invalid configuration of route '${e}': routes must have either a path or a matcher specified`); if ("string" == typeof t.path && "/" === t.path.charAt(0)) throw new Error(`Invalid configuration of route '${e}': path cannot start with a slash`); if ("" === t.path && void 0 !== t.redirectTo && void 0 === t.pathMatch) throw new Error(`Invalid configuration of route '{path: "${e}", redirectTo: "${t.redirectTo}"}': please provide 'pathMatch'. The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`); if (void 0 !== t.pathMatch && "full" !== t.pathMatch && "prefix" !== t.pathMatch) throw new Error(`Invalid configuration of route '${e}': pathMatch can only be set to 'prefix' or 'full'`); t.children && qf(t.children, e) } function Qf(t, e) { return e ? t || e.path ? t && !e.path ? t + "/" : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Gf(t) { const e = t.children && t.children.map(Gf), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && "primary" !== n.outlet && (n.component = $f), n } const Kf = new Dt("ROUTES"); class Zf { constructor(t, e, n, r) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = r } load(t, e) { return this.onLoadStartListener && this.onLoadStartListener(e), this.loadModuleFactory(e.loadChildren).pipe(j(n => { this.onLoadEndListener && this.onLoadEndListener(e); const r = n.create(t); return new cf(cp(r.injector.get(Kf)).map(Gf), r) })) } loadModuleFactory(t) { return "string" == typeof t ? U(this.loader.load(t)) : dp(t()).pipe(z(t => t instanceof Yt ? Ah(t) : U(this.compiler.compileModuleAsync(t)))) } } class Yf { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Xf, this.attachRef = null } } class Xf { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new Yf, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class Jf { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function tm(t) { throw t } function em(t, e, n) { return e.parse("/") } function nm(t, e) { return Ah(null) } let rm = (() => { class t { constructor(t, e, n, r, s, i, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = r, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new S, this.errorHandler = tm, this.malformedUriErrorHandler = em, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: nm, afterPreactivation: nm }, this.urlHandlingStrategy = new Jf, this.routeReuseStrategy = new Vf, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "legacy", this.ngModule = s.get(Zt), this.console = s.get(ta); const l = s.get(pa); this.isNgZoneEnabled = l instanceof pa, this.resetConfig(a), this.currentUrlTree = new fp(new mp([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new Zf(i, o, t => this.triggerEvent(new Zd(t)), t => this.triggerEvent(new Yd(t))), this.routerState = zp(this.currentUrlTree, this.rootComponentType), this.transitions = new fd({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(jh(t => 0 !== t.id), j(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), Lh(t => { let n = !1, r = !1; return Ah(t).pipe(qh(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Lh(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return Ah(t).pipe(Lh(t => { const n = this.transitions.getValue(); return e.next(new Hd(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? xh : [t] }), Lh(t => Promise.resolve(t)), (r = this.ngModule.injector, s = this.configLoader, i = this.urlSerializer, o = this.config, function (t) { return t.pipe(Lh(t => function (t, e, n, r, s) { return new yf(t, e, n, r, s).apply() }(r, s, i, t.extractedUrl, o).pipe(j(e => Object.assign(Object.assign({}, t), { urlAfterRedirects: e }))))) }), qh(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, r, s) { return function (i) { return i.pipe(z(i => function (t, e, n, r, s = "emptyOnly", i = "legacy") { return new Nf(t, e, n, r, s, i).recognize() }(t, e, i.urlAfterRedirects, n(i.urlAfterRedirects), r, s).pipe(j(t => Object.assign(Object.assign({}, i), { targetSnapshot: t }))))) } }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), qh(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), qh(t => { const n = new qd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); var r, s, i, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: s, restoredState: i, extras: o } = t, a = new Hd(n, this.serializeUrl(r), s, i); e.next(a); const l = zp(r, this.rootComponentType).snapshot; return Ah(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: r, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), xh }), Bf(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), qh(t => { const e = new Wd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), j(t => Object.assign(Object.assign({}, t), { guards: xf(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return function (n) { return n.pipe(z(n => { const { targetSnapshot: r, currentSnapshot: s, guards: { canActivateChecks: i, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === i.length ? Ah(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, r) { return U(t).pipe(z(t => function (t, e, n, r, s) { const i = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return i && 0 !== i.length ? Ah(i.map(i => { const o = Ef(i, e, s); let a; if (function (t) { return t && uf(t.canDeactivate) }(o)) a = dp(o.canDeactivate(t, e, n, r)); else { if (!uf(o)) throw new Error("Invalid CanDeactivate guard"); a = dp(o(t, e, n, r)) } return a.pipe(Id()) })).pipe(Pf()) : Ah(!0) }(t.component, t.route, n, e, r)), Id(t => !0 !== t, !0)) }(o, r, s, t).pipe(z(n => n && "boolean" == typeof n ? function (t, e, n, r) { return U(e).pipe(Fd(e => U([Af(e.route.parent, r), Of(e.route, r), If(t, e.path, n), Mf(t, e.route, n)]).pipe(Mh(), Id(t => !0 !== t, !0))), Id(t => !0 !== t, !0)) }(r, i, t, e) : Ah(n)), j(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) })) } }(this.ngModule.injector, t => this.triggerEvent(t)), qh(t => { if (hf(t.guardsResult)) { const e = ip(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } }), qh(t => { const e = new Qd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), jh(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new Vd(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), Bf(t => { if (t.guards.canActivateChecks.length) return Ah(t).pipe(qh(t => { const e = new Gd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), Lh(t => { let n = !1; return Ah(t).pipe((r = this.paramsInheritanceStrategy, s = this.ngModule.injector, function (t) { return t.pipe(z(t => { const { targetSnapshot: e, guards: { canActivateChecks: n } } = t; if (!n.length) return Ah(t); let i = 0; return U(n).pipe(Fd(t => function (t, e, n, r) { return function (t, e, n, r) { const s = Object.keys(t); if (0 === s.length) return Ah({}); const i = {}; return U(s).pipe(z(s => function (t, e, n, r) { const s = Ef(t, e, r); return dp(s.resolve ? s.resolve(e, n) : s(e, n)) }(t[s], e, n, r).pipe(qh(t => { i[s] = t }))), vd(1), z(() => Object.keys(i).length === s.length ? Ah(i) : xh)) }(t._resolve, t, e, r).pipe(j(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), Bp(t, n).resolve), null))) }(t.route, e, r, s)), qh(() => i++), vd(1), z(e => i === n.length ? Ah(t) : xh)) })) }), qh({ next: () => n = !0, complete: () => { if (!n) { const n = new Vd(t.id, this.serializeUrl(t.extractedUrl), "At least one route resolver didn't emit any value."); e.next(n), t.resolve(!1) } } })); var r, s }), qh(t => { const e = new Kd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), Bf(t => { const { targetSnapshot: e, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), j(t => { const e = function (t, e, n) { const r = function t(e, n, r) { if (r && e.shouldReuseRoute(n.value, r.value.snapshot)) { const s = r.value; s._futureSnapshot = n.value; const i = function (e, n, r) { return n.children.map(n => { for (const s of r.children) if (e.shouldReuseRoute(s.value.snapshot, n.value)) return t(e, n, s); return t(e, n) }) }(e, n, r); return new Fp(s, i) } { const r = e.retrieve(n.value); if (r) { const t = r.route; return function t(e, n) { if (e.value.routeConfig !== n.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== n.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); n.value._futureSnapshot = e.value; for (let r = 0; r < e.children.length; ++r)t(e.children[r], n.children[r]) }(n, t), t } { const r = new Hp(new fd((s = n.value).url), new fd(s.params), new fd(s.queryParams), new fd(s.fragment), new fd(s.data), s.outlet, s.component, s), i = n.children.map(n => t(e, n)); return new Fp(r, i) } } var s }(t, e._root, n ? n._root : void 0); return new Up(r, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), qh(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (i = this.rootContexts, o = this.routeReuseStrategy, a = t => this.triggerEvent(t), j(t => (new af(o, t.targetRouterState, t.currentRouterState, a).activate(i), t))), qh({ next() { n = !0 }, complete() { n = !0 } }), (s = () => { if (!n && !r) { this.resetUrlToCurrentUrlTree(); const n = new Vd(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`); e.next(n), t.resolve(!1) } this.currentNavigation = null }, t => t.lift(new Ld(s))), Od(n => { if (r = !0, (s = n) && s.ngNavigationCancelingError) { const r = hf(n.url); r || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new Vd(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(s), r ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); return this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const r = new $d(t.id, this.serializeUrl(t.extractedUrl), n); e.next(r); try { t.resolve(this.errorHandler(n)) } catch (i) { t.reject(i) } } var s; return xh })); var s, i, o, a })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { let e = this.parseUrl(t.url); const n = "popstate" === t.type ? "popstate" : "hashchange", r = t.state && t.state.navigationId ? t.state : null; setTimeout(() => { this.scheduleNavigation(e, n, r, { replaceUrl: !0 }) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { qf(t), this.config = t.map(Gf), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = null) } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: r, fragment: s, preserveQueryParams: i, queryParamsHandling: o, preserveFragment: a } = e; or() && i && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."); const l = n || this.routerState.root, c = a ? this.currentUrlTree.fragment : s; let u = null; if (o) switch (o) { case "merge": u = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), r); break; case "preserve": u = this.currentUrlTree.queryParams; break; default: u = r || null } else u = i ? this.currentUrlTree.queryParams : r || null; return null !== u && (u = this.removeEmptyProps(u)), function (t, e, n, r, s) { if (0 === n.length) return Zp(e.root, e.root, e, r, s); const i = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new Yp(!0, 0, t); let e = 0, n = !1; const r = t.reduce((t, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const e = {}; return hp(r.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (r.segmentPath) return [...t, r.segmentPath] } return "string" != typeof r ? [...t, r] : 0 === s ? (r.split("/").forEach((r, s) => { 0 == s && "." === r || (0 == s && "" === r ? n = !0 : ".." === r ? e++ : "" != r && t.push(r)) }), t) : [...t, r] }, []); return new Yp(n, e, r) }(n); if (i.toRoot()) return Zp(e.root, new mp([], {}), e, r, s); const o = function (t, e, n) { if (t.isAbsolute) return new Xp(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const t = n.snapshot._urlSegment; return new Xp(t, t === e.root, 0) } const r = Kp(t.commands[0]) ? 0 : 1; return function (t, e, n) { let r = t, s = e, i = n; for (; i > s;) { if (i -= s, r = r.parent, !r) throw new Error("Invalid number of '../'"); s = r.segments.length } return new Xp(r, !1, s - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, t.numberOfDoubleDots) }(i, e, t), a = o.processChildren ? ef(o.segmentGroup, o.index, i.commands) : tf(o.segmentGroup, o.index, i.commands); return Zp(o.segmentGroup, a, e, r, s) }(l, this.currentUrlTree, t, u, c) } navigateByUrl(t, e = { skipLocationChange: !1 }) { or() && this.isNgZoneEnabled && !pa.isInAngularZone() && this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?"); const n = hf(t) ? t : this.parseUrl(t), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(r, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { if (hf(t)) return pp(this.currentUrlTree, t, e); const n = this.parseUrl(t); return pp(this.currentUrlTree, n, e) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const r = t[n]; return null != r && (e[n] = r), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new Bd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.currentNavigation = null, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, r, s) { const i = this.getTransition(); if (i && "imperative" !== e && "imperative" === i.source && i.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (i && "hashchange" == e && "popstate" === i.source && i.rawUrl.toString() === t.toString()) return Promise.resolve(!0); if (i && "popstate" == e && "hashchange" === i.source && i.rawUrl.toString() === t.toString()) return Promise.resolve(!0); let o, a, l; s ? (o = s.resolve, a = s.reject, l = s.promise) : l = new Promise((t, e) => { o = t, a = e }); const c = ++this.navigationId; return this.setTransition({ id: c, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: r, resolve: o, reject: a, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, r) { const s = this.urlSerializer.serialize(t); r = r || {}, this.location.isCurrentPathEqualTo(s) || e ? this.location.replaceState(s, "", Object.assign(Object.assign({}, r), { navigationId: n })) : this.location.go(s, "", Object.assign(Object.assign({}, r), { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(Qs), Wt(vp), Wt(Xf), Wt(al), Wt(ai), Wt(Na), Wt(ua), Wt(void 0)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), sm = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.subscription = t.events.subscribe(t => { t instanceof Bd && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } set preserveQueryParams(t) { or() && console && console.warn && console.warn("preserveQueryParams is deprecated, use queryParamsHandling instead."), this.preserve = t } ngOnChanges(t) { this.updateTargetUrlAndHref() } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, r) { if (0 !== t || e || n || r) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const s = { skipLocationChange: im(this.skipLocationChange), replaceUrl: im(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, s), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, preserveQueryParams: im(this.preserve), queryParamsHandling: this.queryParamsHandling, preserveFragment: im(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(_i(rm), _i(Hp), _i(nl)) }, t.\u0275dir = de({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && ki("click", (function (t) { return e.onClick(t.button, t.ctrlKey, t.metaKey, t.shiftKey) })), 2 & t && (Ri("href", e.href, ur), gi("target", e.target)) }, inputs: { routerLink: "routerLink", preserveQueryParams: "preserveQueryParams", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state" }, features: [xe] }), t })(); function im(t) { return "" === t || !!t } let om = (() => { class t { constructor(t, e, n, r, s) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new Mo, this.deactivateEvents = new Mo, this.name = r || "primary", t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, s = new am(t, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(_i(Xf), _i(uo), _i(Fi), ("name", function (t, e) { const n = t.attrs; if (n) { const t = n.length; let e = 0; for (; e < t;) { const r = n[e]; if (Sn(r)) break; if (0 === r) e += 2; else if ("number" == typeof r) for (e++; e < t && "string" == typeof n[e];)e++; else { if ("name" === r) return n[e + 1]; e += 2 } } } return null }(Qe())), _i(qs)) }, t.\u0275dir = de({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class am { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === Hp ? this.route : t === Xf ? this.childContexts : this.parent.get(t, e) } } class lm { } class cm { preload(t, e) { return Ah(null) } } let um = (() => { class t { constructor(t, e, n, r, s) { this.router = t, this.injector = r, this.preloadingStrategy = s, this.loader = new Zf(e, n, e => t.triggerEvent(new Zd(e)), e => t.triggerEvent(new Yd(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(jh(t => t instanceof Bd), Fd(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(Zt); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const r of e) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const t = r._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(t, r)) : r.children && n.push(this.processRoutes(t, r.children)); return U(n).pipe(V(), j(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => this.loader.load(t.injector, e).pipe(z(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(Wt(rm), Wt(Na), Wt(ua), Wt(ai), Wt(lm)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(), hm = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof Hd ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof Bd && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof np && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new np(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(Wt(rm), Wt(Sl), Wt(void 0)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const dm = new Dt("ROUTER_CONFIGURATION"), pm = new Dt("ROUTER_FORROOT_GUARD"), fm = [al, { provide: vp, useClass: wp }, { provide: rm, useFactory: function (t, e, n, r, s, i, o, a = {}, l, c) { const u = new rm(null, t, e, n, r, s, i, cp(o)); if (l && (u.urlHandlingStrategy = l), c && (u.routeReuseStrategy = c), a.errorHandler && (u.errorHandler = a.errorHandler), a.malformedUriErrorHandler && (u.malformedUriErrorHandler = a.malformedUriErrorHandler), a.enableTracing) { const t = qa(); u.events.subscribe(e => { t.logGroup("Router Event: " + e.constructor.name), t.log(e.toString()), t.log(e), t.logGroupEnd() }) } return a.onSameUrlNavigation && (u.onSameUrlNavigation = a.onSameUrlNavigation), a.paramsInheritanceStrategy && (u.paramsInheritanceStrategy = a.paramsInheritanceStrategy), a.urlUpdateStrategy && (u.urlUpdateStrategy = a.urlUpdateStrategy), a.relativeLinkResolution && (u.relativeLinkResolution = a.relativeLinkResolution), u }, deps: [vp, Xf, al, ai, Na, ua, Kf, dm, [class { }, new st], [class { }, new st]] }, Xf, { provide: Hp, useFactory: function (t) { return t.routerState.root }, deps: [rm] }, { provide: Na, useClass: Fa }, um, cm, class { preload(t, e) { return e().pipe(Od(() => Ah(null))) } }, { provide: dm, useValue: { enableTracing: !1 } }]; function mm() { return new Ta("Router", rm) } let gm = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [fm, wm(e), { provide: pm, useFactory: vm, deps: [[rm, new st, new ot]] }, { provide: dm, useValue: n || {} }, { provide: nl, useFactory: _m, deps: [Qa, [new rt(sl), new st], dm] }, { provide: hm, useFactory: ym, deps: [rm, Sl, dm] }, { provide: lm, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : cm }, { provide: Ta, multi: !0, useFactory: mm }, [bm, { provide: Wo, multi: !0, useFactory: Cm, deps: [bm] }, { provide: xm, useFactory: Sm, deps: [bm] }, { provide: Jo, multi: !0, useExisting: xm }]] } } static forChild(e) { return { ngModule: t, providers: [wm(e)] } } } return t.\u0275mod = ue({ type: t }), t.\u0275inj = ut({ factory: function (e) { return new (e || t)(Wt(pm, 8), Wt(rm, 8)) } }), t })(); function ym(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new hm(t, e, n) } function _m(t, e, n = {}) { return n.useHash ? new ol(t, e) : new il(t, e) } function vm(t) { if (t) throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead."); return "guarded" } function wm(t) { return [{ provide: li, multi: !0, useValue: t }, { provide: Kf, multi: !0, useValue: t }] } let bm = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new S } appInitializer() { return this.injector.get(Ka, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(rm), r = this.injector.get(dm); if (this.isLegacyDisabled(r) || this.isLegacyEnabled(r)) t(!0); else if ("disabled" === r.initialNavigation) n.setUpLocationChangeListener(), t(!0); else { if ("enabled" !== r.initialNavigation) throw new Error(`Invalid initialNavigation options: '${r.initialNavigation}'`); n.hooks.afterPreactivation = () => this.initNavigation ? Ah(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation() } return e }) } bootstrapListener(t) { const e = this.injector.get(dm), n = this.injector.get(um), r = this.injector.get(hm), s = this.injector.get(rm), i = this.injector.get(Ia); t === i.components[0] && (this.isLegacyEnabled(e) ? s.initialNavigation() : this.isLegacyDisabled(e) && s.setUpLocationChangeListener(), n.setUpPreloading(), r.init(), s.resetRootComponentType(i.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } isLegacyEnabled(t) { return "legacy_enabled" === t.initialNavigation || !0 === t.initialNavigation || void 0 === t.initialNavigation } isLegacyDisabled(t) { return "legacy_disabled" === t.initialNavigation || !1 === t.initialNavigation } } return t.\u0275fac = function (e) { return new (e || t)(Wt(ai)) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); function Cm(t) { return t.appInitializer.bind(t) } function Sm(t) { return t.bootstrapListener.bind(t) } const xm = new Dt("Router Initializer"); let Em = (() => { class t { triggerAnimation(t) { return t.activatedRouteData.animation || null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["app-root"]], decls: 3, vars: 1, consts: [["outlet", "outlet"]], template: function (t, e) { if (1 & t && (bi(0, "div"), Si(1, "router-outlet", null, 0), Ci()), 2 & t) { const t = Be.lFrame.contextLView[22]; vi("@routerTransition", e.triggerAnimation(t)) } }, directives: [om], styles: [""], data: { animation: [ec("routerTransition", [ac("* => *", [cc(":enter, :leave", ic({ position: "fixed", width: "100%" }), { optional: !0 }), cc(":enter", ic({ transform: "translateX(100%)", opacity: 0 }), { optional: !0 }), sc([rc([cc("@*, :leave", [lc()], { optional: !0 }), cc(":leave", [ic({ transform: "translateX(0%)" }), nc("0.8s ease-in-out", ic({ transform: "translateX(-100%)", opacity: 0 }))], { optional: !0 }), cc(":enter", [ic({ transform: "translateX(100%)", opacity: 0 }), nc("0.8s ease-in-out", ic({ transform: "translateX(0%)", opacity: 1 }))], { optional: !0 }), cc("@*, :enter", [lc()], { optional: !0 })])])])])] } }), t })(); const km = [{ id: "D861BC2A-E9F7-4CF1-8F9B-886C255E723C", name: "Live Server - VsCode Extension \ud83d\udc93", description: "A development local Server with live reload feature.", projectLink: "https://github.com/ritwickdey/vscode-live-server", isFeatured: !0, liveUrl: "https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer", features: ["A quick development server with live browser reload.", "Fully customizable", "Remote Connect through WLAN"], tags: ["node.js"], techStuff: ["Node.js", "vscode-extension"], additionalData: [{ title: "About", data: ["This extension is installed more than 1M (10 lakhs) times from marketplace (by 03.07.18)", "Rating of this extension is 4.8 out of 5 (by 03.07.18)"] }] }, { id: "8108A2CA-4227-4704-99FF-E2250AE6C0D4", name: "Live Sass Compiler - VsCode Extension \ud83d\ude9a", description: "Compile Sass or Scss file to CSS at realtime with live browser reload feature.", projectLink: "https://github.com/ritwickdey/vscode-live-sass-compiler", isFeatured: !0, liveUrl: "https://marketplace.visualstudio.com/items?itemName=ritwickdey.live-sass", features: ["Compile SASS & SCSS with live browser reload", "Fully customizable such as CSS Style & file ext name", "Integrated Autoprefix"], tags: ["node.js"], techStuff: ["Node.js", "vscode-extension"], additionalData: [{ title: "About", data: ["This extension is installed 100K times from marketplace (by 03.07.18)", "Rating of this extension is 4.7 out of 5 (by 03.07.18)"] }] }, { id: "C9D96DC3-C0FE-4EA4-9C53-06C9A8DF69B4", name: "Portfolio Website \ud83d\udc98", description: "This is my portfolio website (SPA), designed with Adobe XD & developed with Angular 7", isFeatured: !0, projectLink: "https://github.com/ritwickdey/ritwickdey.github.io", liveUrl: "https://ritwickdey.github.io", features: ["No 3rd party CSS library or component is used \ud83d\udc96", "Filtering Project Cards in Portfolio Page", "Angular animation is used for various transition effects", "Reuseable Components & Responsive UI", "CI/CD to deploy website"], tags: ["angular", "css"], techStuff: ["Angular 7", "Angular Animation", "CSS", "TypeScript"], additionalData: [] }, { id: "5DF00C04-0DE4-4A56-B5F9-5E564BB8FF76", name: "Organic Shop \ud83c\udf40", description: "A Shopping Website build with Angular 4 and Firebase", projectLink: "https://github.com/ritwickdey/organic-shop", isFeatured: !0, liveUrl: "https://oshop-ritwick.firebaseapp.com/", features: ["Login through Facebook & Gmail", "Cart System", "Realtime updates (through Firebase Realtime Database)", "Only Admin can perform Create/Edit/Delete operations & upload photos of items", "Normal User can buy items & view their own orders", "Admin can access all orders", "Responsive UI using Bootstrap 4"], tags: ["angular", "firebase"], techStuff: ["Angular 4", "Firebase Realtime Database", "Firebase Auth"], additionalData: [] }, { id: "BA56C7BD-7263-4810-9EA4-04123482BBC4", name: "Social Diary \ud83d\udcd6", description: "A simple story app where people can share their story and can edit/delete\n    only their stories and everyone can read all stories from timeline.", isFeatured: !0, projectLink: "https://github.com/ritwickdey/social-diary", liveUrl: "https://ritwickdey.github.io/social-diary/", features: ["HTML tags are supported in story", "Login using Google Account", "Searching feature of stories", "Sorting stories using date/title & alphabetically", "Filtering stories using date range", "Responsive UI"], tags: ["react.js", "css"], techStuff: ["React with Redux Architecture", "React Routing", "CSS Modules", "Firestore Database & Rules", "Firebase Authentication", "Responsive UI with pure CSS (No library \ud83d\ude04)", "Travis CI to deploy"], additionalData: [] }, { id: "BD7972A2-197A-4236-841F-7D298A149726", name: "Cake Shop \ud83c\udf82", description: "A sample Cake Shop Website built with ASP.NET Core (Multi-Page Application)", projectLink: "https://github.com/ritwickdey/Cake-Shop", liveUrl: null, isFeatured: !0, features: ["Only Admin can perform Create/Edit/Delete cakes & manage Orders.", "Normal User can only can buy cakes & view their orders.", "Managing Cart System using cookie.", "Client Side & Server side validation", "Cookie Based Authentication & Authorization - Not Session", "Login through either Username or Email", "Responsive UI", "Repository Pattern", "Application Architecture is decoupled form ORM (Entity Framework)"], tags: ["asp.net", "asp.net core"], techStuff: ["ASP.NET Core 2.0", "Entity Framework Core", "ASP.NET Identity", "Razor View", "AutoMapper", "jQuery & Bootstap 4"], additionalData: [] }, { id: "6E020215-0E1A-48A0-B07E-E79B32164FED", name: "Sale It \ud83d\udc5c", description: "A Simple Vehicle Dealer App built with ASP.NET Core + Angular 4 ", projectLink: "https://github.com/ritwickdey/Sale-It", liveUrl: "https://ritwick-sale-it.azurewebsites.net", features: ["Only Admin/Moderator can perform Create/Edit/Delete operations & upload photos", "Normal User only can view the vehicle details & see report of vehicles in charts view", "Server Side Sorting & Pagination", "Role Based Athentication"], tags: ["asp.net", "angular"], techStuff: ["Angular 4", "ASP.NET Core", "Entity Framework Core", "Auth0", "AutoMapper", "Chart.js"], additionalData: [] }, { id: "5EBCE406-643A-4229-BFE6-32281D3892A6", name: "Social Network \ud83d\udc66\ud83d\udc67", description: "A chatting web app using MEAN Stack (Node.js, Angular 4, Express.js & MongoDB) ", projectLink: "https://github.com/ritwickdey/social-network-mean-stack", liveUrl: "https://social-network-mean.herokuapp.com", features: ["A chatting web app using MEAN Stack", "Colorful chat bars"], tags: ["node.js", "angular", "moongodb", "express.js"], techStuff: ["Angular 4", "Node.js & Express.js", "MongoDB", "JWT based Authentication", "Lazy loading of Angular"], additionalData: [] }, { id: "3C6A816A-011C-479B-8C9F-2DDA4E5087F5", name: "Official Tech Fest Website \ud83c\udfe2", description: "Official Tech Fest (2018) Website of Our College", isFeatured: !0, projectLink: "https://github.com/ritwickdey/bgi-tech-fest-2k18", liveUrl: "https://ritwickdey.github.io/bgi-tech-fest-2k18/", features: ["No heavy CSS library such as `Bootstrap` or `Material-CSS` is used", "Responsive UI", "Parallax scrolling effect"], tags: ["html", "css"], techStuff: ["HTML & CSS", "jQuery"], additionalData: [] }, { id: "AEBCD0CF-6B8C-477F-B9A2-D4F39720E3F5", name: "Indecision App \ud83e\udd14", description: "A simple app made with React - this app will make your decision from your choice (It is my First React App)", projectLink: "https://github.com/ritwickdey/indecision-app", liveUrl: "https://ritwickdey.github.io/indecision-app/", features: ["A decision making app", "Responsive UI"], tags: ["react.js"], techStuff: ["React", "CI to deploy"], additionalData: [] }, { id: "81BF5A1B-D401-401E-B85A-1A5785377025", name: "Expensify App \ud83d\udcb0", description: "An Private Expense Manager. This app is built with React with Redux architecture", projectLink: "https://github.com/ritwickdey/expensify-app", isFeatured: !0, liveUrl: "https://ritwickdey.github.io/expensify-app", features: ["Searching, Sorting, Filtering expenses", "Login using Google Account", "Only you can access your expenses", "stories using date/title & alphabetically", "Responsive UI"], tags: ["react.js", "css"], techStuff: ["React with Redux Architecture", "React Routing", "CSS - BEM Patten", "Firestore Realtime & Rules", "Firebase Authentication", "React Testing using Jest & Enzyme", "Travis CI to deploy"], additionalData: [] }, { id: "695EBE0A-498A-4C4E-86E4-BFE1DF601D97", name: "Live Server - Web Browser Extension \u23f3", description: "A browser extension that helps you to live reload feature\n  for dynamic content/pages", projectLink: "https://github.com/ritwickdey/live-server-web-extension", liveUrl: "https://chrome.google.com/webstore/detail/live-server-web-extension/fiegdmejfepffgpnejdinekhfieaogmj/", features: ["Live Reload features for dynamic content such as ASP.NET, Node.js or PHP."], tags: ["others"], techStuff: ["browsers-extension"], additionalData: [{ title: "About", data: ["This extension has 2K active Google Chrome user (by 24.04.18)"] }] }, { id: "E9C02983-DC50-48EC-8361-6C618FFE83F5", name: "We Mate \ud83d\udc6a", description: "A simple zero level chat website made with ASP.NET Form and SQL Server as Backend service.", projectLink: "https://github.com/ritwickdey/WeMate", liveUrl: null, features: ["Registration Page", "Login Page", "Chat Page", "Master Page", "A secret Admin Page [But Not much Secure. LOL!]"], tags: ["asp.net", "asp.net form"], techStuff: ["ASP.NET Form", "SQL Server"], additionalData: [] }, { id: "3246277A-E2BC-476A-8D8A-AA781D9D54D4", name: "Create Files & Folders - VSCode Extension \ud83d\udcc2", description: "A small extension that help you to create files & folder in Style of Atom", projectLink: "https://github.com/ritwickdey/vscode-create-file-folder", liveUrl: "https://marketplace.visualstudio.com/items?itemName=ritwickdey.create-file-folder", features: ["Create Multiple files and folders in one go"], tags: ["node.js"], techStuff: ["Node.js", "vscode-extension"], additionalData: [{ title: "About", data: ["This extension is installed 1.6K times from marketplace (by 22.04.18)", "Actually I developed this extension just only for me. Because I don't like that default way. :)"] }] }, { id: "A1B3308D-8BC5-4A7B-81A7-4190A9A41D0B", name: "Face Detection \ud83d\udd0e", description: "Face Detection using Google Chrome API", projectLink: "https://github.com/ritwickdey/face-detector-chrome-api", liveUrl: "https://ritwickdey.github.io/face-detector-chrome-api", features: ["Face Detection api of Google Chrome"], tags: ["others", "chrome"], techStuff: ["Chrome API"], additionalData: [{ title: "Note", data: ["This is an experimental features of Google Chrome"] }] }, { id: "302A54B8-9BBB-4D8E-B7E0-BDA0B11CF6E5", name: "Bike Shop Template \ud83d\udeb2", description: "A Sample basic HTML Template for front page of a Bike company", projectLink: "https://github.com/ritwickdey/simple-bike-shopping-site", liveUrl: "https://ritwickdey.github.io/simple-bike-shopping-site", features: ["Custom CSS & Bootstrap", "Parallax scrolling effect"], tags: ["html", "css"], techStuff: ["HTML & CSS", "design"], additionalData: [] }, { id: "E22C8CC5-FB9B-45F5-B0FF-8603AB9EF9A1", name: "Factorial of Large Number \ud83c\udf1f", description: "A browser extension that helps you to live reload feature\n  for dynamic content/pages", projectLink: "https://github.com/ritwickdey/LargeNumberFactorialUsingC", liveUrl: null, features: ["Factorial of Large Number Using C"], tags: ["others", "c"], techStuff: ["C Programming"], additionalData: [] }]; let Tm = (() => { class t { constructor() { } getProjects() { return km } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac }), t })(); const Pm = function (t) { return { "tada-animation": t } }; let Om = (() => { class t { constructor(t) { this.router = t, this.ExploreMe = new Mo, this.startTadaAnimation = !1 } ngOnInit() { setInterval(() => { this.startTadaAnimation = !this.startTadaAnimation }, 3e3) } onExploreMeClick() { this.ExploreMe.emit(), this.router.navigateByUrl("/") } } return t.\u0275fac = function (e) { return new (e || t)(_i(rm)) }, t.\u0275cmp = oe({ type: t, selectors: [["app-profile-card"]], outputs: { ExploreMe: "ExploreMe" }, decls: 29, vars: 3, consts: [[1, "container"], [1, "card"], [1, "strip-block"], [1, "profile-logo"], ["src", "assets/img/Profile-Pic-Maulik.jpg", "alt", ""], [1, "strip"], [1, "short-details"], [1, "tagLine"], [1, "quote"], [1, "details"], [1, "nameBlock"], [1, "round-shape", "name"], [1, "divider"], [1, "stick", "stick1"], [1, "stick", "stick2"], [1, "bio"], [3, "ngClass", "mouseover"], [1, "round-shape", "projects-link", 3, "click"]], template: function (t, e) { 1 & t && (bi(0, "div", 0), bi(1, "div", 1), bi(2, "div", 2), bi(3, "div", 3), Si(4, "img", 4), Ci(), Si(5, "div", 5), bi(6, "div", 6), bi(7, "h4", 7), Ai(8, " Developer "), Ci(), bi(9, "blockquote", 8), Ai(10, ' "I love to help others in the way of self-learning" '), Ci(), Ci(), Ci(), bi(11, "div", 9), bi(12, "div", 10), bi(13, "h1", 11), Ai(14, " Maulik Sojitra "), Ci(), bi(15, "div", 12), Si(16, "div", 13), Si(17, "div", 14), Ci(), Ci(), bi(18, "p", 15), Ai(19, " I love coding, new technologies. I'm mostly interested in Full Stack Web Development. "), Si(20, "br"), Ai(21, " I love to work with ASP.NET Core, ASP.NET MVC, Angular & AngularJs. "), Ci(), bi(22, "div", 16), ki("mouseover", (function () { return e.startTadaAnimation = !1 })), bi(23, "a", 17), ki("click", (function () { return e.onExploreMeClick() })), bi(24, "span"), Ai(25, " Explore Me "), Ci(), Ci(), Ci(), Ci(), bi(26, "div", 12), Si(27, "div", 13), Si(28, "div", 14), Ci(), Ci(), Ci()), 2 & t && (Or(22), vi("ngClass", Ao(1, Pm, e.startTadaAnimation))) }, directives: [pl], styles: ['@charset "UTF-8";.container[_ngcontent-%COMP%]{display:flex;width:100%;min-height:100vh;align-items:center;padding:2rem 0;justify-content:center;background-color:#007a94;color:#fff}.container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]{background-color:#212121;height:auto;max-height:90%;width:45rem;text-align:center;overflow-x:hidden;position:relative;z-index:1;-webkit-user-select:none;-moz-user-select:none;user-select:none;overflow:hidden;border-radius:5px;box-shadow:12px 11px 14px 0 rgba(0,0,0,.36);transition:all .3s ease-in-out;animation:dropin 1s ease-in-out 0s 1 normal both}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]{height:14rem;width:14rem;margin-top:5.5rem;display:inline-block;position:relative;z-index:5;border-radius:50%;perspective:1500px;animation:dropin 1s ease-in-out .4s 1 normal both}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:relative;border:.8rem solid #e74c3c;border-radius:50%}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]:after, .container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:100%;width:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;transition:all .5s ease-in-out;perspective:1500px}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]:after{content:"Maulik Sojitra";display:flex;position:absolute;justify-content:center;align-items:center;border-radius:50%;background-color:#e74c3c;border:.8rem solid #db381b;top:0;left:0;z-index:10;font-size:2rem;transform:rotateY(180deg)}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]:hover   img[_ngcontent-%COMP%]{transform:rotateY(180deg)}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]:hover:after{transform:rotateY(0deg)}.container[_ngcontent-%COMP%]   .strip[_ngcontent-%COMP%]{background-color:#e74c3c;height:16.2rem;width:150%;margin-left:-5rem;margin-top:-8rem;transform:rotate(-16deg);z-index:-1;position:absolute;animation:stripAnimation 1s ease-in-out 1.4s 1 normal both}.container[_ngcontent-%COMP%]   .strip[_ngcontent-%COMP%]:after{content:"";display:inline-block;position:absolute;height:100%;width:20%;background-color:#fff;opacity:0;top:0;left:0}.container[_ngcontent-%COMP%]   .strip-block[_ngcontent-%COMP%]:hover   .strip[_ngcontent-%COMP%]:after, .container[_ngcontent-%COMP%]   .strip[_ngcontent-%COMP%]:hover:after{animation:fadeLeftToRight 1s ease-in-out 0s 1 normal both}.container[_ngcontent-%COMP%]   .short-details[_ngcontent-%COMP%]{position:relative;animation:dropin 1s ease-in-out .4s 1 normal both}.container[_ngcontent-%COMP%]   .short-details[_ngcontent-%COMP%]   .tagLine[_ngcontent-%COMP%]{display:block;width:100%;font-size:1.6rem;font-weight:lighter;font-style:italic;padding:.5rem}.container[_ngcontent-%COMP%]   .short-details[_ngcontent-%COMP%]   .quote[_ngcontent-%COMP%]{font-family:Cormorant Garamond,serif;display:inline-block;font-size:2rem;font-weight:400;width:65%;padding:.5rem 2rem 1rem;line-height:1.2}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]{margin-top:6rem}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .nameBlock[_ngcontent-%COMP%]{transition:all .3s ease-in-out;animation:dropin 1s ease-in-out .6s 1 normal both}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .nameBlock[_ngcontent-%COMP%]:hover   .divider[_ngcontent-%COMP%] > .stick1[_ngcontent-%COMP%]{transform:translateX(-2rem)!important}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .nameBlock[_ngcontent-%COMP%]:hover   .divider[_ngcontent-%COMP%] > .stick2[_ngcontent-%COMP%]{transform:translateX(2rem)!important}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .name[_ngcontent-%COMP%]{display:inline-block;position:relative;width:60%;font-size:2rem;font-weight:400;line-height:1.6;text-transform:uppercase;letter-spacing:.2rem}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .bio[_ngcontent-%COMP%]{display:inline-block;width:70%;font-size:1.6rem;line-height:1.2;font-weight:lighter;margin:.4rem .4rem .8rem;text-align:center;word-spacing:1px;animation:dropin 1s ease-in-out .8s 1 normal both}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]{display:inline-block;width:15rem;line-height:2.2;font-size:1.4rem;padding:.5rem;margin-top:1.5rem;color:#fff;text-decoration:none;cursor:pointer;vertical-align:middle;transition:all .3s ease-in-out;box-shadow:7px 5px 8px 0 rgba(0,0,0,.31);animation:dropin 1s ease-in-out 1s 1 normal both}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{transform:translateX(.7rem);display:inline-block;transition:all .3s ease-in-out}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]:hover{background-color:#db381b;animation-play-state:paused}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]:hover:after{transform:translateX(.2rem);opacity:1}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]:hover   span[_ngcontent-%COMP%]{transform:translateX(-.2rem)}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]:active{transform:scale(.8);box-shadow:4px 5px 5px 0 rgba(0,0,0,.31)}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]   .projects-link[_ngcontent-%COMP%]:after{content:"\xbb";position:relative;opacity:0;vertical-align:sub;font-size:2.7rem;line-height:0;transform:translateX(25px);display:inline-block;transition:all .3s ease-in-out}.container[_ngcontent-%COMP%]   .social[_ngcontent-%COMP%]{display:block;padding:0 3rem 3rem;margin-top:.6rem;animation:dropin 1s ease-in-out 1.2s 1 normal both}.container[_ngcontent-%COMP%]   .social[_ngcontent-%COMP%]   .social-icon[_ngcontent-%COMP%]{display:inline-block;width:3.4rem;height:3.4rem;margin:.2rem .5rem;background-color:#fff;transition:all .3s ease-in-out}.container[_ngcontent-%COMP%]   .social[_ngcontent-%COMP%]   .social-icon[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:100%;width:100%}.container[_ngcontent-%COMP%]   .social[_ngcontent-%COMP%]   .social-icon[_ngcontent-%COMP%]:hover{transform:scale(1.3)}.divider[_ngcontent-%COMP%]{padding:1rem;display:flex;flex-flow:column;align-items:center;position:relative}.divider[_ngcontent-%COMP%]   .stick[_ngcontent-%COMP%]{display:inline-block;position:relative;height:2px;background-color:#e74c3c;margin:2px 0;width:75%;clear:both}.divider[_ngcontent-%COMP%]   .stick1[_ngcontent-%COMP%]{transform:translateX(1.5rem);transition:all .3s ease-in-out}.divider[_ngcontent-%COMP%]   .stick2[_ngcontent-%COMP%]{transform:translateX(-1.5rem);transition:all .3s ease-in-out}.divider[_ngcontent-%COMP%]:hover   .stick1[_ngcontent-%COMP%]{transform:translateX(-1.5rem)!important}.divider[_ngcontent-%COMP%]:hover   .stick2[_ngcontent-%COMP%]{transform:translateX(1.5rem)!important}.round-shape[_ngcontent-%COMP%]{background-color:#e74c3c;border-radius:100rem;padding:.2rem 2rem}.tada-animation[_ngcontent-%COMP%]{animation:tada 1s ease-in-out 0s 2 normal both}@media (max-height:740px) and (min-width:436px){html[_ngcontent-%COMP%]{font-size:8px}}@media (max-height:660px) and (min-width:436px){html[_ngcontent-%COMP%]{font-size:6px}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]{margin-top:8rem}}@media (max-height:740px){.container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]{overflow-y:auto}}@media only screen and (max-width:768px){.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]{margin-top:30px!important}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]{margin-top:8rem!important}}@media (max-width:460px) and (min-height:100px){html[_ngcontent-%COMP%]{font-size:8px}.container[_ngcontent-%COMP%]   .card[_ngcontent-%COMP%]{width:90vw}.container[_ngcontent-%COMP%]   .profile-logo[_ngcontent-%COMP%]{width:14rem;height:14rem;margin-top:14rem}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]{margin-top:10rem}}@media (max-width:360px) and (min-height:100px){html[_ngcontent-%COMP%]{font-size:7px}.container[_ngcontent-%COMP%]   .details[_ngcontent-%COMP%]{margin-top:7rem}.container[_ngcontent-%COMP%]   .social[_ngcontent-%COMP%]   .social-icon[_ngcontent-%COMP%]{width:2.4rem;height:2.4rem}}@media (max-width:270px) and (min-height:100px){html[_ngcontent-%COMP%]{font-size:5px}.container[_ngcontent-%COMP%]   .social[_ngcontent-%COMP%]   .social-icon[_ngcontent-%COMP%]{width:1.4rem;height:1.4rem}}@media (max-width:170px) and (min-height:100px){html[_ngcontent-%COMP%]{font-size:1px}}@keyframes fadeLeftToRight{0%{opacity:.1;left:-10%}to{opacity:.7;left:120%}}@keyframes dropin{0%{opacity:0;transform:scale(0)}to{opacity:1;transform:scale(1)}}@keyframes tada{0%{transform:scale(1) rotate(0deg)}10%{transform:scale(1.1) rotate(-4deg)}20%{transform:scale(1.1) rotate(4deg)}30%{transform:scale(1.1) rotate(-4deg)}40%{transform:scale(1.1) rotate(4deg)}50%{transform:scale(1.1) rotate(-4deg)}60%{transform:scale(1.1) rotate(4deg)}70%{transform:scale(1.1) rotate(-4deg)}80%{transform:scale(1.1) rotate(4deg)}90%{transform:scale(1.1) rotate(-4deg)}to{transform:scale(1) rotate(0deg)}}@keyframes stripAnimation{0%{transform:translateX(-10px) rotate(0deg);opacity:0}to{transform:translateX(0) rotate(-16deg);opacity:1}}'] }), t })(), Am = (() => { class t { constructor() { } ngOnInit() { this.logoStyles = { height: this.height, width: this.width }, this.imgStyle = { borderWidth: this.borderWidth } } ngOnChanges(t) { this.ngOnInit() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["app-dp-logo"]], inputs: { height: "height", width: "width", borderWidth: "borderWidth" }, features: [xe], decls: 2, vars: 2, consts: [[1, "profile-logo", 3, "ngStyle"], ["src", "assets/img/Profile-Pic-Maulik.jpg", "alt", "my pic", 3, "ngStyle"]], template: function (t, e) { 1 & t && (bi(0, "div", 0), Si(1, "img", 1), Ci()), 2 & t && (vi("ngStyle", e.logoStyles), Or(1), vi("ngStyle", e.imgStyle)) }, directives: [wl], styles: ['.profile-logo[_ngcontent-%COMP%]{height:14rem;width:14rem;display:inline-block;position:relative;z-index:5;border-radius:50%;perspective:1500px;transition:all .2s ease-in-out;animation:dropin 1s ease-in-out .4s 1 normal both}.profile-logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{position:relative;border:.8rem solid #e74c3c;border-radius:50%}.profile-logo[_ngcontent-%COMP%]:after, .profile-logo[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{height:100%;width:100%;-webkit-backface-visibility:hidden;backface-visibility:hidden;transition:all .5s ease-in-out;perspective:1500px}.profile-logo[_ngcontent-%COMP%]:after{content:"Maulik Sojitra";display:flex;position:absolute;color:#fff;justify-content:center;align-items:center;border-radius:50%;background-color:#e74c3c;border:.8rem solid #db381b;top:0;left:0;z-index:10;font-size:.8em}.profile-logo[_ngcontent-%COMP%]:after, .profile-logo[_ngcontent-%COMP%]:hover   img[_ngcontent-%COMP%]{transform:rotateY(180deg)}.profile-logo[_ngcontent-%COMP%]:hover:after{transform:rotateY(0deg)}'] }), t })(); const Mm = function () { return ["/portfolio"] }, Im = function () { return ["/about"] }, Rm = function () { return ["/profiles"] }, Nm = function (t) { return { "tada-animation": t } }; let jm = (() => { class t { constructor() { this.ExploreMe = new Mo, this.startTadaAnimation = !1 } ngOnInit() { setInterval(() => { this.startTadaAnimation = !this.startTadaAnimation }, 3e3) } onExploreMeClick() { this.ExploreMe.emit() } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["app-landing-page"]], outputs: { ExploreMe: "ExploreMe" }, decls: 26, vars: 9, consts: [[1, "overlay"], [1, "root-container"], [1, "navbar"], [1, "nav-items"], [1, "nav-item", 3, "routerLink"], [1, "container"], [1, "dp-logo"], [1, "short-bio"], [1, "quote"], [1, "name"], [1, "strip"], [3, "ngClass", "click", "mouseover"], [1, "special-btn"], [1, "stick"], [1, "stick-design"]], template: function (t, e) { 1 & t && (Si(0, "div", 0), bi(1, "div", 1), bi(2, "div", 2), bi(3, "div", 3), bi(4, "a", 4), Ai(5, "Portfolio"), Ci(), bi(6, "a", 4), Ai(7, "About & Skills"), Ci(), bi(8, "a", 4), Ai(9, "Profiles"), Ci(), Ci(), Ci(), bi(10, "div", 5), Si(11, "app-dp-logo", 6), bi(12, "h4", 7), Ai(13, "Developer"), Ci(), bi(14, "q", 8), Ai(15, "Help others in the way of self-learning"), Ci(), bi(16, "div", 9), bi(17, "p"), Ai(18, " MAULIK SOJITRA "), Ci(), Si(19, "div", 10), Ci(), bi(20, "span", 11), ki("click", (function () { return e.onExploreMeClick() }))("mouseover", (function () { return e.startTadaAnimation = !1 })), bi(21, "button", 12), bi(22, "span"), Ai(23, " Explore Me "), Ci(), Ci(), Ci(), bi(24, "div", 13), Si(25, "div", 14), Ci(), Ci(), Ci()), 2 & t && (Or(4), vi("routerLink", Oo(4, Mm)), Or(2), vi("routerLink", Oo(5, Im)), Or(2), vi("routerLink", Oo(6, Rm)), Or(12), vi("ngClass", Ao(7, Nm, e.startTadaAnimation))) }, directives: [sm, Am, pl], styles: ['@charset "UTF-8";.root-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;height:100vh;width:100vw}.overlay[_ngcontent-%COMP%]{height:100vh;width:100vw;overflow:hidden;z-index:-1;display:block;background:#212121;position:fixed;right:0;top:0;pointer-events:none;-webkit-clip-path:ellipse(50vw 40vh at 50% 50%);clip-path:ellipse(50vw 40vh at 50% 50%);transform:scale(2) translate(27vw,-18vh) rotate(335deg);animation:leftToRight 1s ease-in-out .2s both}.dp-logo[_ngcontent-%COMP%]{font-size:2rem;animation:fadeIn 1s ease-in-out .2s both}.navbar[_ngcontent-%COMP%]{width:100%;color:#f8f8f8;font-size:2rem;padding:1.6rem;display:flex;justify-content:center;align-items:center}.nav-items[_ngcontent-%COMP%]   .nav-item[_ngcontent-%COMP%]{display:inline-block;padding:.2rem 0;margin:.6rem 1rem;-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:pointer;border-bottom:.3rem solid #007a94;color:#f8f8f8;text-decoration:none}.container[_ngcontent-%COMP%]{display:flex;flex:1;flex-direction:column;justify-content:center;align-items:center;height:100%;font-size:1.6rem;color:#f8f8f8;margin-top:5%}.short-bio[_ngcontent-%COMP%]{font-size:1.6rem;padding:1.6rem;font-weight:400;animation:fadeIn 1s ease-in-out .2s both}.quote[_ngcontent-%COMP%]{font-size:1.8rem;padding:0 1rem 1rem;animation:fadeIn 1s ease-in-out .4s both}.name[_ngcontent-%COMP%], .quote[_ngcontent-%COMP%]{font-family:Cormorant Garamond,serif}.name[_ngcontent-%COMP%]{font-size:2.4rem;font-weight:700;line-height:1.6;padding-top:.6rem;text-transform:uppercase;letter-spacing:.4rem;word-spacing:.2rem;text-align:center;margin-bottom:-2.5rem;animation:fadeIn 1s ease-in-out .6s both}.name[_ngcontent-%COMP%]:hover   .strip[_ngcontent-%COMP%]:after{left:-1rem}.name[_ngcontent-%COMP%]:hover   .strip[_ngcontent-%COMP%]:before{left:1rem}.strip[_ngcontent-%COMP%]{display:inline-block;position:relative;width:28rem;margin:auto auto 2rem;animation:fadeIn 1s ease-in-out .8s both}.strip[_ngcontent-%COMP%]:before{top:0;left:-1rem}.strip[_ngcontent-%COMP%]:after, .strip[_ngcontent-%COMP%]:before{transition:all .3s ease-in-out;content:"";position:absolute;display:inline-block;height:2px;background-color:#e74c3c;width:100%;margin:auto}.strip[_ngcontent-%COMP%]:after{top:4px;left:1rem}.special-btn[_ngcontent-%COMP%]{min-width:15rem;line-height:2.2;font-size:1.4rem;padding:.5rem;margin-top:2rem;background-color:#e74c3c;color:#fff;border:none;outline:none;border-radius:100rem;cursor:pointer;animation:fadeIn 1s ease-in-out 1s both;box-shadow:7px 5px 8px 0 rgba(0,0,0,.31)}.special-btn[_ngcontent-%COMP%], .special-btn[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{transition:all .3s ease-in-out;position:relative}.special-btn[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{transform:translateX(.7rem);display:inline-block}.special-btn[_ngcontent-%COMP%]:hover{background-color:#db381b;animation-play-state:paused}.special-btn[_ngcontent-%COMP%]:hover:after{transform:translateX(.2rem);opacity:1}.special-btn[_ngcontent-%COMP%]:hover   span[_ngcontent-%COMP%]{transform:translateX(-.2rem)}.special-btn[_ngcontent-%COMP%]:active{transform:scale(.8);box-shadow:4px 5px 5px 0 rgba(0,0,0,.31)}.special-btn[_ngcontent-%COMP%]:after{content:"\xbb";position:relative;opacity:0;vertical-align:sub;font-size:2.7rem;line-height:0;transform:translateX(25px);display:inline-block;transition:all .3s ease-in-out}.stick[_ngcontent-%COMP%]{flex:1;margin-top:-1rem;width:100%;overflow:hidden;position:relative;z-index:-1;animation:fadeIn 1s ease-in-out 1s both}.stick[_ngcontent-%COMP%]:after{content:"";height:200vh;width:1.6rem;display:inline-block;top:0;z-index:5;box-shadow:7px 5px 8px 0 rgba(0,0,0,.31)}.stick[_ngcontent-%COMP%]   .stick-design[_ngcontent-%COMP%], .stick[_ngcontent-%COMP%]:after{position:absolute;background-color:#e74c3c;left:50%;transform:translate(-50%)}.stick[_ngcontent-%COMP%]   .stick-design[_ngcontent-%COMP%]{padding:1.4rem;min-width:8.5rem;top:3.5rem;border-radius:100rem;z-index:6;box-shadow:13px 0 20px 0 rgba(0,0,0,.2);transition:all 1s ease-in-out}.stick[_ngcontent-%COMP%]   .stick-design[_ngcontent-%COMP%]:after{content:"";height:.8rem;width:.8rem;position:absolute;border-radius:50%;background-color:#212121;top:50%;left:50%;transform:translate(-50%,-50%);box-shadow:2rem 0 0 #212121,-2rem 0 0 #212121}.tada-animation[_ngcontent-%COMP%]{animation:tada 1s ease-in-out 0s 2 normal both}@keyframes leftToRight{0%{display:relative;opacity:.1;left:-20%}to{display:relative;opacity:1;left:0}}@keyframes fadeIn{0%{opacity:0;transform:scale(0)}to{opacity:1;transform:scale(1)}}@keyframes tada{0%{transform:scale(1) rotate(0deg)}10%{transform:scale(1.1) rotate(-4deg)}20%{transform:scale(1.1) rotate(4deg)}30%{transform:scale(1.1) rotate(-4deg)}40%{transform:scale(1.1) rotate(4deg)}50%{transform:scale(1.1) rotate(-4deg)}60%{transform:scale(1.1) rotate(4deg)}70%{transform:scale(1.1) rotate(-4deg)}80%{transform:scale(1.1) rotate(4deg)}90%{transform:scale(1.1) rotate(-4deg)}to{transform:scale(1) rotate(0deg)}}@keyframes stripAnimation{0%{transform:translateX(-10px) rotate(0deg);opacity:0}to{transform:translateX(0) rotate(-16deg);opacity:1}}'] }), t })(), Dm = (() => { class t { constructor() { this.appEscCancelation = new Mo } onKeydownHandler(t) { "Escape" === t.key && this.appEscCancelation.emit({ msg: "Escape Btn Clicked", event: t }) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = de({ type: t, selectors: [["", "appEscCancelation", ""]], hostBindings: function (t, e) { 1 & t && ki("keydown", (function (t) { return e.onKeydownHandler(t) }), !1, jn) }, outputs: { appEscCancelation: "appEscCancelation" } }), t })(); const Fm = function (t) { return { transform: t } }; function Lm(t, e) { if (1 & t) { const t = xi(); bi(0, "div", 3), ki("click", (function (n) { We(t); const r = e.$implicit; return Oi().onNavItemClick(n, r.url) })), bi(1, "div", 4), Ai(2), Ci(), Ci() } if (2 & t) { const t = e.$implicit, n = e.even; vi("ngStyle", Ao(3, Fm, n ? "translateX(10%)" : "translateX(-10%)")), Or(1), vi("ngStyle", Ao(5, Fm, n ? "translateX(-10%)" : "translateX(10%)")), Or(1), Ii(" ", t.displayName, " ") } } let Um = (() => { class t { constructor(t) { this.router = t, this.navLinks = [{ displayName: "Portfolio", url: "/portfolio" }, { displayName: "About & Skills", url: "/about" }, { displayName: "Contacts & Profiles", url: "/profiles" }, { displayName: "Profile Card", url: "/profile-card" }], this.cancellation = new Mo } ngOnInit() { } onBgClick() { this.cancellation.emit() } onNavItemClick(t, e) { t.stopPropagation(), this.router.navigateByUrl(e) } } return t.\u0275fac = function (e) { return new (e || t)(_i(rm)) }, t.\u0275cmp = oe({ type: t, selectors: [["app-navigator"]], outputs: { cancellation: "cancellation" }, decls: 3, vars: 2, consts: [["appEscCancelation", "", 1, "navigator-container", 3, "appEscCancelation", "click"], [1, "navLinks"], ["class", "navLink", 3, "ngStyle", "click", 4, "ngFor", "ngForOf"], [1, "navLink", 3, "ngStyle", "click"], [3, "ngStyle"]], template: function (t, e) { 1 & t && (bi(0, "div", 0), ki("appEscCancelation", (function () { return e.onBgClick() }))("click", (function () { return e.onBgClick() })), bi(1, "div", 1), yi(2, Lm, 3, 7, "div", 2), Ci(), Ci()), 2 & t && (Or(1), vi("@slideIn", void 0), Or(1), vi("ngForOf", e.navLinks)) }, directives: [Dm, ml, wl], styles: ["*[_ngcontent-%COMP%]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.navigator-container[_ngcontent-%COMP%]{font-family:Cormorant Garamond,serif;position:fixed;min-width:100vw;min-height:100vh;background:rgba(85,85,85,.9);top:0;left:0;z-index:5}.navigator-container[_ngcontent-%COMP%], .navLinks[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.navLinks[_ngcontent-%COMP%]{width:90vw;flex-direction:column}.navLink[_ngcontent-%COMP%]{padding:2rem 0;margin:1rem 0;width:40%;min-width:40rem;font-size:2.4rem;font-weight:700;text-transform:uppercase;letter-spacing:1px;text-align:center;background:hsla(0,0%,97.3%,.5);cursor:pointer;border-radius:.5rem}@media (max-width:1300px){.navLink[_ngcontent-%COMP%]{width:60%}}@media (max-width:640px){.navLink[_ngcontent-%COMP%]{width:100%}}.navLink[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{color:#fff;text-decoration:none}"], data: { animation: [ec("slideIn", [ac("* => *", [cc(":enter", ic({ marginLeft: "50%", opacity: 0 }), { optional: !0 }), cc(":leave", ic({ marginLeft: "0%", opacity: 1 }), { optional: !0 }), cc(":enter", [uc("0.2s", [nc("0.5s ease-out", oc([ic({ offset: 0 }), ic({ marginLeft: "0%", opacity: .8, offset: .8 }), ic({ marginLeft: "-10%", opacity: 1, offset: .9 }), ic({ marginLeft: "0%", opacity: 1, offset: 1 })]))])], { optional: !0 }), cc(":leave", [uc("0.2s", [nc("0.5s ease-in", oc([ic({ offset: 0 }), ic({ marginLeft: "10%", offset: .1 }), ic({ marginLeft: "0%", offset: .4 }), ic({ marginLeft: "-50%", opacity: 0, offset: 1 })]))])], { optional: !0 })])])] } }), t })(); function zm(t, e) { if (1 & t) { const t = xi(); bi(0, "app-navigator", 2), ki("cancellation", (function () { return We(t), Oi().showNavigationMenu = !1 })), Ci() } } let Hm = (() => { class t { constructor() { this.showNavigationMenu = !1 } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["app-profile"]], decls: 3, vars: 2, consts: [[3, "cancellation", 4, "ngIf"], [3, "ExploreMe"], [3, "cancellation"]], template: function (t, e) { 1 & t && (bi(0, "div"), yi(1, zm, 1, 0, "app-navigator", 0), Ci(), bi(2, "app-landing-page", 1), ki("ExploreMe", (function () { return e.showNavigationMenu = !0 })), Ci()), 2 & t && (vi("@animate", void 0), Or(1), vi("ngIf", e.showNavigationMenu)) }, directives: [yl, jm, Um], styles: [""], data: { animation: [ec("animate", [ac("* => *", [cc(":leave, :enter", [lc()], { optional: !0 })])])] } }), t })(); const Bm = ["cursor"]; let Vm = (() => { class t { constructor() { this.text = "", this.time = 1e3, this.delay = 500, this.displayText = "", this.isProcessRunning = !1 } ngOnInit() { } ngOnChanges(t) { this.text && this.startRendering() } startRendering() { this.displayText = "", this.isProcessRunning || setTimeout(() => { const t = Math.round(this.time / this.text.length), e = this.text.split(""); this.renderTextByLetter(e, t) }, this.delay), this.isProcessRunning = !0 } renderTextByLetter(t, e, n = t[0]) { if (!t || t.length <= 0) return this.cursorRef.nativeElement.classList.add("cursor__animate"), void (this.isProcessRunning = !1); setTimeout(() => { this.displayText += n; const r = t.slice(1); this.renderTextByLetter(r, e, r[0]) }, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["app-typing"]], viewQuery: function (t, e) { var n; 1 & t && Vo(Bm, !0), 2 & t && Bo(n = $o()) && (e.cursorRef = n.first) }, inputs: { text: "text", time: "time", delay: "delay" }, features: [xe], decls: 5, vars: 1, consts: [[1, "text"], [1, "cursor", "cursor__animate"], ["cursor", ""]], template: function (t, e) { 1 & t && (bi(0, "span", 0), Ai(1), bi(2, "span", 1, 2), Ai(4, "|"), Ci(), Ci()), 2 & t && (Or(1), Ii("", e.displayText, " ")) }, styles: ['.cursor[_ngcontent-%COMP%], .text[_ngcontent-%COMP%]{display:inline-block}.cursor[_ngcontent-%COMP%]{content:"|"}.cursor__animate[_ngcontent-%COMP%]{animation:fadeInOut .8s cubic-bezier(1,-.18,0,1.35) .5s infinite}@keyframes fadeInOut{0%{opacity:0}to{opacity:1}}'] }), t })(), $m = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = oe({ type: t, selectors: [["app-back-icon"]], decls: 2, vars: 0, consts: [[1, "icon"], ["src", "data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeD0iMHB4IiB5PSIwcHgiIHZpZXdCb3g9IjAgMCA1MTIuMDAxIDUxMi4wMDEiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMi4wMDEgNTEyLjAwMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSIxMjhweCIgaGVpZ2h0PSIxMjhweCI+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTM4NC44MzQsMTgwLjY5OWMtMC42OTgsMC0zNDguNzMzLDAtMzQ4LjczMywwbDczLjMyNi04Mi4xODdjNC43NTUtNS4zMyw0LjI4OS0xMy41MDUtMS4wNDEtMTguMjYgICAgYy01LjMyOC00Ljc1NC0xMy41MDUtNC4yOS0xOC4yNiwxLjA0MWwtODIuNTgyLDkyLjU2Yy0xMC4wNTksMTEuMjc4LTEwLjA1OCwyOC4yODIsMC4wMDEsMzkuNTU3bDgyLjU4Miw5Mi41NjEgICAgYzIuNTU2LDIuODY1LDYuMDk3LDQuMzIzLDkuNjU0LDQuMzIzYzMuMDY0LDAsNi4xMzktMS4wODMsOC42MDYtMy4yODJjNS4zMy00Ljc1NSw1Ljc5NS0xMi45MywxLjA0MS0xOC4yNmwtNzMuMzI2LTgyLjE4OCAgICBjMCwwLDM0OC4wMzQsMCwzNDguNzMzLDBjNTUuODU4LDAsMTAxLjMsNDUuNDQ0LDEwMS4zLDEwMS4zcy00NS40NDMsMTAxLjMtMTAxLjMsMTAxLjNoLTYxLjU4ICAgIGMtNy4xNDMsMC0xMi45MzMsNS43OTEtMTIuOTMzLDEyLjkzM2MwLDcuMTQyLDUuNzksMTIuOTMzLDEyLjkzMywxMi45MzNoNjEuNThjNzAuMTIsMCwxMjcuMTY2LTU3LjA0NiwxMjcuMTY2LTEyNy4xNjYgICAgQzUxMiwyMzcuNzQ1LDQ1NC45NTQsMTgwLjY5OSwzODQuODM0LDE4MC42OTl6IiBmaWxsPSIjZTc0YzNjIi8+Cgk8L2c+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg=="]], template: function (t, e) { 1 & t && (bi(0, "div", 0), Si(1, "img", 1), Ci()) }, styles: [".icon[_ngcontent-%COMP%]{max-width:25rem;max-height:25rem;display:inline-block}.icon[_ngcontent-%COMP%], .icon[_ngcontent-%COMP%]   img[_ngcontent-%COMP%]{width:100%;height:100%}"] }), t })(); const qm = function (t) { return { "key-skill--disabled": t } }; function Wm(t, e) { if (1 & t) { const t = xi(); bi(0, "button", 2), ki("click", (function () { We(t); const n = e.$implicit; return Oi().toogleSkillSelection(n) })), Ai(1), Ci() } if (2 & t) { const t = e.$implicit; vi("disabled", Oi().disableIfOneBtn(t))("ngClass", Ao(3, qm, !t.isSelected)), Or(1), Ii(" ", t.displayName, " ") } } let Qm = (() => { class t { constructor(t) { this.tagsService = t, this.keySkills = t.tags } ngOnInit() { } toogleSkillSelection(t) { this.tagsService.toogleTagSelection(t.displayName) } disableIfOneBtn(t) { const e = this.keySkills.filter(t => t.isSelected); return 1 === e.length && e[0].displayName === t.displayName } } return t.\u0275fac = function (e) { return new (e || t)(_i(Va)) }, t.\u0275cmp = oe({ type: t, selectors: [["app-key-skill-btns"]], decls: 2, vars: 1, consts: [[1, "key-skills"], ["class", "key-skill", 3, "disabled", "ngClass", "click", 4, "ngFor", "ngForOf"], [1, "key-skill", 3, "disabled", "ngClass", "click"]], template: function (t, e) { 1 & t && (bi(0, "div", 0), yi(1, Wm, 2, 5, "button", 1), Ci()), 2 & t && (Or(1), vi("ngForOf", e.keySkills)) }, directives: [ml, pl], styles: ['.key-skills[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;justify-content:center;margin:1rem auto}.key-skills[_ngcontent-%COMP%]   .key-skill[_ngcontent-%COMP%]{z-index:99;position:relative;font-size:1.6rem;margin:.6rem;padding:.4rem 2rem;border:2px solid #db381b;border-radius:50rem;cursor:pointer;color:#fff;line-height:1.5;background-color:#db381b;transition:all .3s ease-in-out;outline:none;box-shadow:.4rem .5rem .9rem rgba(0,0,0,.25)}.key-skills[_ngcontent-%COMP%]   .key-skill[_ngcontent-%COMP%]:disabled{background-color:#e85a41;border:2px solid #e85a41;box-shadow:none}.key-skills[_ngcontent-%COMP%]   .key-skill[_ngcontent-%COMP%]:hover:disabled{margin:.6rem;padding:.4rem 2rem;cursor:not-allowed}.key-skills[_ngcontent-%COMP%]   .key-skill[_ngcontent-%COMP%]:hover{padding:.4rem 3.2rem;margin:.6rem 2rem}@media screen and (max-width:640px){.key-skills[_ngcontent-%COMP%]   .key-skill[_ngcontent-%COMP%]:hover{margin:.6rem;padding:.4rem 2rem}}.key-skills[_ngcontent-%COMP%]   .key-skill.key-skill--disabled[_ngcontent-%COMP%]{border:2px solid #db381b;background-color:initial;overflow:hidden;transition:all .3s ease-in-out}.key-skills[_ngcontent-%COMP%]   .key-skill.key-skill--disabled[_ngcontent-%COMP%]:after{content:"";position:absolute;display:block;width:100%;height:2px;background-color:#db381b;top:50%;left:0;transform:rotate(-14deg);transition:all .3s ease-in-out}'] }), t })(); const Gm = ["portfolioHeader"], Km = ["portfolioArea"], Zm = ["portfolioSelectionArea"], Ym = function (t) { return { "portfolio-selection__fixed": t } }; let Xm = (() => { class t { constructor(t, e) { this.router = t, this.tagsService = e, this.animatedTypingText = "\ud83d\ude4b Hey, sort my projects by clicking the categories. ", this.dpLogoStyle = { height: "12rem", width: "12rem", borderWidth: "3px" }, this.setFixedPostion = !1 } ngOnInit() { this.updateAnimatedTextOnce() } updateAnimatedTextOnce() { let t = 0; this.tagsService.onTagUpdate.subscribe(() => { 0 === t && (this.animatedTypingText = "Great! Have a great day! \ud83d\ude0a", t++) }) } onScroll() { const t = this.portfolioHeaderRef.nativeElement, e = this.portfolioAreaRef.nativeElement, n = this.portfolioSelectionAreaRef.nativeElement, r = t.scrollHeight + t.offsetTop; if (window.scrollY > r) e.style.marginTop = n.scrollHeight + n.offsetTop + 5 + "px", this.setFixedPostion = !0; else { e.style.marginTop = "inherit", this.setFixedPostion = !1; const n = 1 - window.scrollY / (r + 40); this.dpLogoStyle = Object.assign(Object.assign({}, this.dpLogoStyle), { height: 12 * n + "rem", width: 12 * n + "rem" }), t.style.opacity = n.toString() } } onBackBtnClick() { this.router.navigateByUrl("/") } } return t.\u0275fac = function (e) { return new (e || t)(_i(rm), _i(Va)) }, t.\u0275cmp = oe({ type: t, selectors: [["app-portfolio"]], viewQuery: function (t, e) { var n; 1 & t && (Vo(Gm, !0), Vo(Km, !0), Vo(Zm, !0)), 2 & t && (Bo(n = $o()) && (e.portfolioHeaderRef = n.first), Bo(n = $o()) && (e.portfolioAreaRef = n.first), Bo(n = $o()) && (e.portfolioSelectionAreaRef = n.first)) }, hostBindings: function (t, e) { 1 & t && ki("scroll", (function () { return e.onScroll() }), !1, Nn) }, decls: 17, vars: 7, consts: [[1, "portfolio-bg"], [1, "portfolio-container"], [1, "portfolio-header"], ["portfolioHeader", ""], [3, "height", "width", "borderWidth"], ["time", "2000", "delay", "1500", 3, "text"], [1, "portfolio-area"], ["portfolioArea", ""], [1, "back-icon", 3, "click"], [1, "portfolio-selection", 3, "ngClass"], ["portfolioSelectionArea", ""]], template: function (t, e) { 1 & t && (bi(0, "div", 0), bi(1, "div", 1), bi(2, "div", 2, 3), Si(4, "app-dp-logo", 4), Si(5, "app-typing", 5), Ci(), bi(6, "div", 6, 7), bi(8, "div", 8), ki("click", (function () { return e.onBackBtnClick() })), Si(9, "app-back-icon"), Ci(), bi(10, "div", 9, 10), bi(12, "h1"), Ai(13, "PORTFOLIO"), Ci(), Si(14, "app-key-skill-btns"), Ci(), bi(15, "h1"), Ai(16, "Application is in development"), Ci(), Ci(), Ci(), Ci()), 2 & t && (Or(4), vi("height", e.dpLogoStyle.height)("width", e.dpLogoStyle.width)("borderWidth", e.dpLogoStyle.borderWidth), Or(1), vi("text", e.animatedTypingText), Or(5), vi("ngClass", Ao(5, Ym, e.setFixedPostion))) }, directives: [Am, Vm, $m, pl, Qm], styles: ['.portfolio-bg[_ngcontent-%COMP%]{min-height:100vh;min-width:100vw;position:relative;background-color:#007a94;overflow:hidden;display:flex}.portfolio-bg[_ngcontent-%COMP%]:after{content:"";position:fixed;display:block;height:100vh;min-height:500px;width:100vw;min-width:500px;overflow:hidden;background-color:#212121;transform:rotate(-11deg) scale(1.5);top:-65vh;left:-25vw}.portfolio-container[_ngcontent-%COMP%]{display:flex;flex:1;justify-content:center;align-items:center;height:100%;width:100%;z-index:10;padding:3.5rem;flex-direction:column;color:#fff}.portfolio-container[_ngcontent-%COMP%]   .portfolio-header[_ngcontent-%COMP%]{display:flex;justify-content:stretch;margin:auto;align-items:center;font-size:1.8rem;-webkit-user-select:none;-moz-user-select:none;user-select:none}.portfolio-container[_ngcontent-%COMP%]   .portfolio-header[_ngcontent-%COMP%] > *[_ngcontent-%COMP%]{display:inline-block;padding:1rem 2rem;transition:all .3s cubic-bezier(.175,.885,.32,1.275)}.portfolio-container[_ngcontent-%COMP%]   .portfolio-area[_ngcontent-%COMP%]{margin:.4rem 0;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:50;position:relative}.portfolio-container[_ngcontent-%COMP%]   .portfolio-area[_ngcontent-%COMP%]   .portfolio-selection[_ngcontent-%COMP%]{-webkit-user-select:none;-moz-user-select:none;user-select:none}.portfolio-container[_ngcontent-%COMP%]   .portfolio-area[_ngcontent-%COMP%]   .portfolio-selection.portfolio-selection__fixed[_ngcontent-%COMP%]{position:fixed;top:0;z-index:1;background-color:#212121;width:100%;box-shadow:0 8px 20px rgba(0,0,0,.4)}.portfolio-container[_ngcontent-%COMP%]   .portfolio-area[_ngcontent-%COMP%]   .portfolio-selection[_ngcontent-%COMP%] > h1[_ngcontent-%COMP%]{font-family:Cormorant Garamond,serif;font-weight:400;font-size:3.2rem;letter-spacing:1px;margin:1rem auto;text-align:center}@media (max-width:900px){.portfolio-container[_ngcontent-%COMP%]{padding:3.5rem .5rem}}@media (max-width:74rem){.portfolio-header[_ngcontent-%COMP%]{flex-direction:column}}'] }), t })(); const Jm = [{ type: "Programming Language", names: ["C#", "JavaScript", "TypeScript"] }, { type: "Backend", names: ["ASP.NET Core/MVC/WebAPI"] }, { type: "Frontend", names: ["Angular", "AngularJs", "CSS", "HTML", "jQuery"] }, { type: "Database & ORM", names: ["SQL Server", "MongoDB", "Entity Framework"] }, { type: "Others", names: ["Git & GitHub", "CI/CD", "REST API", "JWT"] }]; let tg = (() => { class t { constructor() { } getSkills() { return Jm } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = ct({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function eg(t, e) { if (1 & t && (bi(0, "div"), bi(1, "h4", 10), Ai(2), Ci(), bi(3, "h4", 11), Ai(4), Ci(), Ci()), 2 & t) { const t = e.$implicit; Or(2), Mi(t.type), Or(2), Mi(t.names.join(", ")) } } function ng(t, e) { if (1 & t && (bi(0, "a", 12), Si(1, "img", 10), Ci()), 2 & t) { const t = e.$implicit; vi("href", t.url, ur), Or(1), vi("title", t.name)("src", t.iconUrl, ur)("alt", t.name) } } function rg(t, e) { if (1 & t && (bi(0, "a", 12), Si(1, "img", 10), Ci()), 2 & t) { const t = e.$implicit; vi("href", t.url, ur), Or(1), vi("title", t.name)("src", t.iconUrl, ur)("alt", t.name) } } const sg = gm.forRoot([{ path: "", component: Hm, pathMatch: "full", data: { animation: "landing-page" } }, { path: "profile-card", component: Om, data: { animation: "profile-card" } }, { path: "portfolio", component: Xm, data: { animation: "portfolio" } }, { path: "about", component: (() => { class t { constructor(t, e) { this.skillsService = t, this.router = e } ngOnInit() { this.skills = this.skillsService.getSkills() } onBackClick() { this.router.navigateByUrl("/") } } return t.\u0275fac = function (e) { return new (e || t)(_i(tg), _i(rm)) }, t.\u0275cmp = oe({ type: t, selectors: [["app-about"]], decls: 19, vars: 1, consts: [[1, "back-icon", 3, "click"], [1, "overlay"], [1, "container"], [1, "side1"], [1, "skill-header"], ["height", "13rem", "width", "13rem", 1, "dp-logo"], [1, "text-container"], [1, "side2"], [1, "skill-container"], [4, "ngFor", "ngForOf"], [1, "skill-type"], [1, "skill-names"]], template: function (t, e) { 1 & t && (bi(0, "div", 0), ki("click", (function () { return e.onBackClick() })), Si(1, "app-back-icon"), Ci(), Si(2, "span", 1), bi(3, "div", 2), bi(4, "div", 3), bi(5, "h1", 4), Ai(6, "ABOUT"), Ci(), Si(7, "app-dp-logo", 5), bi(8, "div", 6), bi(9, "p"), Ai(10, " I started programming with AngularJS in 2014 then I jumped to .NET & ASP.NET with C# for Web App development and now I am working with ASP.NET Core, Angular, Angular.js. "), Ci(), Si(11, "br"), bi(12, "p"), Ai(13, " I've built few of npm packages for Angular which are downloaded and used in many applications. "), Ci(), Ci(), Ci(), bi(14, "div", 7), bi(15, "div", 8), bi(16, "h1", 4), Ai(17, " Skills "), Ci(), yi(18, eg, 5, 2, "div", 9), Ci(), Ci(), Ci()), 2 & t && (Or(18), vi("ngForOf", e.skills)) }, directives: [$m, Am, ml], styles: ['.overlay[_ngcontent-%COMP%]{display:inline-block;height:100vh;width:100vw;top:0;left:-100%;position:fixed;background:#212121;transform:scale(2) skew(-10deg);z-index:-1;transition:all .3s ease-in-out}@media (max-width:1040px){.overlay[_ngcontent-%COMP%]{transform:scale(2) skew(-55deg)}}.container[_ngcontent-%COMP%]{font-size:1.4rem;width:100vw;display:flex;flex-direction:row;justify-content:space-around;color:#f8f8f8;align-items:center;padding:5rem}@media (max-width:1040px){.container[_ngcontent-%COMP%]{flex-direction:column}}.container[_ngcontent-%COMP%]   .side1[_ngcontent-%COMP%]{flex:1;height:100%;display:flex;flex-direction:column;align-items:center}@media (max-width:1040px){.container[_ngcontent-%COMP%]   .side1[_ngcontent-%COMP%]{flex:none;height:auto}}.container[_ngcontent-%COMP%]   .side1[_ngcontent-%COMP%] > h1[_ngcontent-%COMP%]{margin-bottom:0;padding:3rem .8rem .2rem}.container[_ngcontent-%COMP%]   .side2[_ngcontent-%COMP%]{flex:1;height:100%;display:flex;flex-direction:column;align-items:center}.text-container[_ngcontent-%COMP%]{height:auto;max-width:32rem;background:#e74c3c;padding:5.8rem 1.8rem 3rem;border-radius:2rem;min-width:34rem}.dp-logo[_ngcontent-%COMP%]{font-size:1.6rem;transform:translateY(45%)}.skill-container[_ngcontent-%COMP%]{padding:3rem 1.8rem;margin-left:5rem}@media (max-width:1040px){.skill-container[_ngcontent-%COMP%]{margin:auto}}.skill-header[_ngcontent-%COMP%]{margin:2rem 0 3.8rem;position:relative;letter-spacing:2px;padding-bottom:0;font-size:3.2rem;font-family:Cormorant Garamond,serif;justify-content:flex-start}.skill-header[_ngcontent-%COMP%]:after{content:"";position:absolute;display:inline-block;width:100%;height:3px;top:100%;left:0;background:#f8f8f8}.skill-type[_ngcontent-%COMP%]{position:relative;margin:1.2rem 0;padding-bottom:.2rem;font-size:1.6rem}.skill-type[_ngcontent-%COMP%]:after{content:"";position:absolute;display:inline-block;width:70%;height:1.5px;top:100%;left:0;background:#f8f8f8}.skill-names[_ngcontent-%COMP%]{margin-left:2.8rem;margin-bottom:2rem;margin-top:-.6rem}'] }), t })(), data: { animation: "about" } }, { path: "contact", redirectTo: "/profiles" }, { path: "profiles", component: (() => { class t { constructor(t) { this.router = t, this.contactProfile = { profile: [{ name: "Facebook", url: "https://facebook.com", iconUrl: "./assets/icons/facebook.svg" }, { name: "Twitter", url: "https://twitter.com", iconUrl: "./assets/icons/twitter.svg" }, { name: "Instagram", url: "https://www.instagram.com", iconUrl: "./assets/icons/instagram.svg" }, { name: "LinkedIn", url: "https://www.linkedin.com/in/mauliksojitra", iconUrl: "./assets/icons/linkedin.svg" }], work: [{ name: "GitHub", url: "https://github.com/Mauliksojitra", iconUrl: "./assets/icons/github.svg" }, { name: "Stackoverflow", url: "https://stackoverflow.com/story/mauliksojitra", iconUrl: "./assets/icons/stackoverflow.svg" }] }, this.email = { name: "Email", url: "mailto:mauliksojitra@outlook.com", iconUrl: "./assets/icons/email.svg" }, this.vscodeMarketplace = { name: "VSCode Extension Publisher", url: "https://marketplace.visualstudio.com/publishers/ritwickdey", iconUrl: "./assets/icons/vscode.svg" } } ngOnInit() { } onBackClick() { this.router.navigateByUrl("/") } } return t.\u0275fac = function (e) { return new (e || t)(_i(rm)) }, t.\u0275cmp = oe({ type: t, selectors: [["app-contact"]], decls: 18, vars: 7, consts: [[1, "back-icon", 3, "click"], [1, "root"], [1, "page-header"], [1, "container"], [1, "part", "part1"], [1, "section", "icons", "flex-1"], ["target", "_blank", "class", "img icon", 3, "href", 4, "ngFor", "ngForOf"], [1, "part", "part2"], [1, "section", "min-section"], ["target", "_top", 1, "img", "icon", 3, "href"], [3, "title", "src", "alt"], ["class", "img icon", "target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 1, "img", "icon", 3, "href"]], template: function (t, e) { 1 & t && (bi(0, "div", 0), ki("click", (function () { return e.onBackClick() })), Si(1, "app-back-icon"), Ci(), bi(2, "div", 1), bi(3, "div"), bi(4, "h1", 2), Ai(5, "CONTACT & PROFILES"), Ci(), Ci(), bi(6, "div", 3), bi(7, "div", 4), bi(8, "div", 5), yi(9, ng, 2, 4, "a", 6), Ci(), Ci(), bi(10, "div", 7), bi(11, "div", 8), bi(12, "a", 9), Si(13, "img", 10), Ci(), bi(14, "p"), Ai(15), Ci(), Ci(), bi(16, "div", 5), yi(17, rg, 2, 4, "a", 11), Ci(), Ci(), Ci(), Ci()), 2 & t && (Or(9), vi("ngForOf", e.contactProfile.profile), Or(3), vi("href", e.email.url, ur), Or(1), vi("title", e.email.name)("src", e.email.iconUrl, ur)("alt", e.email.name), Or(2), Mi(e.email.url.replace("mailto:", "")), Or(2), vi("ngForOf", e.contactProfile.work)) }, directives: [$m, ml], styles: ['a[_ngcontent-%COMP%]{text-decoration:none;color:#f2f2f2}.root[_ngcontent-%COMP%]{min-height:100vh;min-width:100vw;justify-content:center;flex-direction:column}.root[_ngcontent-%COMP%], .root[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child{display:flex;align-items:center}.root[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:first-child{flex:6}.root[_ngcontent-%COMP%] > [_ngcontent-%COMP%]:nth-child(2){flex:8}.page-header[_ngcontent-%COMP%]{color:#f8f8f8;position:relative;font-size:3rem;letter-spacing:1px;word-spacing:1.5px;margin:2rem 0;-webkit-user-select:none;-moz-user-select:none;user-select:none;font-family:Cormorant Garamond,serif}.page-header[_ngcontent-%COMP%]:after{content:"";position:absolute;display:inline-block;width:100%;height:2px;top:100%;left:0;background:#f8f8f8}.icon[_ngcontent-%COMP%]{height:5rem;width:5rem;cursor:pointer;transition:all .3s ease-in-out;animation:fade 1.4s ease-in-out .4s 1 both}.icon[_ngcontent-%COMP%]:hover{transform:scale(1.1)}@media (max-width:690px){.icon[_ngcontent-%COMP%]{height:3rem;width:3rem}}@media (max-width:350px){.icon[_ngcontent-%COMP%]{height:2rem;width:2rem}}.img[_ngcontent-%COMP%] > img[_ngcontent-%COMP%]{width:100%;height:100%}.container[_ngcontent-%COMP%]{width:95%;max-width:75rem;display:flex;flex:1;align-items:center;justify-content:flex-start;flex-direction:column}.icons[_ngcontent-%COMP%]{padding-right:2rem;padding-left:2rem}.section[_ngcontent-%COMP%]{background:#212121;margin:2px;justify-content:space-around;padding-top:2.4rem;padding-bottom:2.4rem}.section[_ngcontent-%COMP%], .section.min-section[_ngcontent-%COMP%]{display:flex;align-items:center}.section.min-section[_ngcontent-%COMP%]{width:35%;justify-content:center;flex-direction:column;color:#f8f8f8;font-size:1.6rem}@media (max-width:690px){.section.min-section[_ngcontent-%COMP%]{font-size:1.2rem}}@media (max-width:350px){.section.min-section[_ngcontent-%COMP%]{font-size:.8rem}}.section.min-section[_ngcontent-%COMP%] > p[_ngcontent-%COMP%]{width:90%;text-align:center;word-break:break-word;padding-top:.8rem;margin:0 1rem -.8rem}.part[_ngcontent-%COMP%]{display:flex;width:100%}.flex-1[_ngcontent-%COMP%]{flex:1}@keyframes fade{0%{opacity:0}to{opacity:1}}'] }), t })(), data: { animation: "contact" } }, { path: "**", redirectTo: "/" }], { useHash: !0 }); let ig = (() => { class t { } return t.\u0275mod = ue({ type: t, bootstrap: [Em] }), t.\u0275inj = ut({ factory: function (e) { return new (e || t) }, providers: [Tm, Va, tg, { provide: sl, useValue: "!" }], imports: [[Jl, Sh, sg, pd.register("ngsw-worker.js", { enabled: !0 })]] }), t })(); (function () { if (ir) throw new Error("Cannot enable prod mode after platform setup."); sr = !1 })(), Yl().bootstrapModule(ig).catch(t => console.error(t)) }, zn8P: function (t, e) { function n(t) { return Promise.resolve().then((function () { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e })) } n.keys = function () { return [] }, n.resolve = n, t.exports = n, n.id = "zn8P" } }, [[0, 0]]]);